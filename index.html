<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AKU NAK MELETUP - Ultimate Downloader</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    --primary: #8b5cf6;
    --primary-dark: #7c3aed;
    --secondary: #06b6d4;
    --success: #10b981;
    --danger: #ef4444;
    --warning: #f59e0b;
    --dark: #0f0f23;
    --card: #1a1a2e;
    --text: #e4e4e7;
    --muted: #71717a;
    --border: rgba(139, 92, 246, 0.2);
  }

  body {
    min-height: 100vh;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    color: var(--text);
    position: relative;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      radial-gradient(circle at 20% 80%, rgba(139, 92, 246, 0.3) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(6, 182, 212, 0.3) 0%, transparent 50%),
      radial-gradient(circle at 40% 40%, rgba(236, 72, 153, 0.2) 0%, transparent 50%);
    animation: float 20s ease-in-out infinite;
    pointer-events: none;
  }

  @keyframes float {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    33% { transform: translate(-20px, -20px) rotate(1deg); }
    66% { transform: translate(20px, -10px) rotate(-1deg); }
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
    position: relative;
    z-index: 1;
  }

  .header {
    text-align: center;
    margin-bottom: 3rem;
    animation: slideDown 0.8s ease-out;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  h1 {
    font-size: 3.5rem;
    font-weight: 900;
    background: linear-gradient(135deg, #fff 0%, #8b5cf6 50%, #06b6d4 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 0.5rem;
    text-shadow: 0 0 80px rgba(139, 92, 246, 0.5);
    animation: glow 3s ease-in-out infinite;
  }

  @keyframes glow {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
  }

  .subtitle {
    color: var(--muted);
    font-size: 1.1rem;
    opacity: 0.9;
  }

  .main-card {
    background: rgba(26, 26, 46, 0.95);
    backdrop-filter: blur(20px);
    border-radius: 24px;
    padding: 2rem;
    box-shadow: 
      0 20px 60px rgba(0, 0, 0, 0.3),
      0 0 0 1px var(--border),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
    animation: fadeInUp 0.8s ease-out 0.2s both;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .input-group {
    display: flex;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
  }

  .input-wrapper {
    flex: 1;
    min-width: 250px;
    position: relative;
  }

  input {
    width: 100%;
    padding: 1rem 1.5rem;
    background: rgba(15, 15, 35, 0.6);
    border: 2px solid var(--border);
    border-radius: 12px;
    color: var(--text);
    font-size: 1rem;
    transition: all 0.3s ease;
  }

  input:focus {
    outline: none;
    border-color: var(--primary);
    background: rgba(15, 15, 35, 0.8);
    box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.1);
  }

  input::placeholder {
    color: var(--muted);
  }

  select {
    padding: 1rem 1.5rem;
    background: rgba(15, 15, 35, 0.6);
    border: 2px solid var(--border);
    border-radius: 12px;
    color: var(--text);
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 150px;
  }

  select:hover {
    border-color: var(--primary);
    background: rgba(15, 15, 35, 0.8);
  }

  select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.1);
  }

  .btn-primary {
    padding: 1rem 2rem;
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
    border: none;
    border-radius: 12px;
    color: white;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    min-width: 120px;
  }

  .btn-primary::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s ease;
  }

  .btn-primary:hover::before {
    left: 100%;
  }

  .btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
  }

  .btn-primary:active {
    transform: translateY(0);
  }

  .btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .preview-area {
    margin-top: 2rem;
    animation: fadeIn 0.5s ease;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .preview-card {
    background: rgba(15, 15, 35, 0.4);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 1.5rem;
    margin-bottom: 1rem;
  }

  .media-title {
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 1rem;
    color: var(--text);
  }

  .media-info {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .info-badge {
    padding: 0.5rem 1rem;
    background: rgba(139, 92, 246, 0.2);
    border: 1px solid var(--primary);
    border-radius: 20px;
    font-size: 0.9rem;
    color: var(--primary);
  }

  video, audio {
    width: 100%;
    max-width: 100%;
    border-radius: 12px;
    background: #000;
    margin: 1rem 0;
  }

  img {
    max-width: 100%;
    border-radius: 12px;
    margin: 1rem 0;
  }

  .url-list {
    background: rgba(15, 15, 35, 0.6);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1rem;
    margin: 1rem 0;
    max-height: 300px;
    overflow-y: auto;
  }

  .url-list::-webkit-scrollbar {
    width: 8px;
  }

  .url-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
  }

  .url-list::-webkit-scrollbar-thumb {
    background: var(--primary);
    border-radius: 4px;
  }

  .url-category {
    font-weight: 600;
    color: var(--text);
    margin: 0.5rem 0;
    padding-bottom: 0.25rem;
    border-bottom: 1px solid var(--border);
  }

  .url-item {
    font-size: 0.85rem;
    color: var(--muted);
    padding: 0.25rem 0;
    word-break: break-all;
    transition: color 0.2s ease;
  }

  .url-item:hover {
    color: var(--text);
  }

  .url-item.video { color: var(--success); }
  .url-item.audio { color: var(--secondary); }
  .url-item.image { color: var(--warning); }

  .download-section {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
    flex-wrap: wrap;
  }

  .btn-download {
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
    border: none;
    border-radius: 10px;
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
  }

  .btn-download:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
  }

  .btn-alt {
    padding: 0.75rem 1.5rem;
    background: rgba(139, 92, 246, 0.2);
    border: 1px solid var(--primary);
    border-radius: 10px;
    color: var(--primary);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
  }

  .btn-alt:hover {
    background: rgba(139, 92, 246, 0.3);
    transform: translateY(-2px);
  }

  .loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .progress-bar {
    width: 100%;
    height: 6px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
    overflow: hidden;
    margin: 1rem 0;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--secondary));
    border-radius: 3px;
    transition: width 0.3s ease;
    animation: shimmer 2s linear infinite;
  }

  @keyframes shimmer {
    0% { background-position: -200% center; }
    100% { background-position: 200% center; }
  }

  .error-msg {
    padding: 1rem;
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid var(--danger);
    border-radius: 10px;
    color: var(--danger);
    margin: 1rem 0;
  }

  .success-msg {
    padding: 1rem;
    background: rgba(16, 185, 129, 0.1);
    border: 1px solid var(--success);
    border-radius: 10px;
    color: var(--success);
    margin: 1rem 0;
  }

  pre {
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 1rem;
    color: var(--muted);
    font-size: 0.85rem;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 300px;
    overflow-y: auto;
    margin-top: 1rem;
  }

  .debug-toggle {
    margin-top: 1rem;
    padding: 0.5rem 1rem;
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--muted);
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .debug-toggle:hover {
    background: rgba(0, 0, 0, 0.3);
    color: var(--text);
  }
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>AKU NAK MELETUP</h1>
      <p class="subtitle">Ultimate Media Downloader - YouTube, TikTok, Instagram & More</p>
    </div>

    <div class="main-card">
      <div class="input-group">
        <div class="input-wrapper">
          <input 
            id="inputUrl" 
            type="url" 
            placeholder="Paste your link here (YouTube, TikTok, Instagram, Facebook, etc.)"
            autocomplete="off"
          />
        </div>
        <select id="platform">
          <option value="auto">üîç Auto Detect</option>
          <option value="ytmp4">üìπ YouTube Video</option>
          <option value="ytmp3">üéµ YouTube Audio</option>
          <option value="tiktok">üé≠ TikTok</option>
          <option value="instagram">üì∑ Instagram</option>
          <option value="facebook">üë§ Facebook</option>
          <option value="pinterest">üìå Pinterest</option>
          <option value="terabox">‚òÅÔ∏è Terabox</option>
          <option value="gdrive">üìÅ Google Drive</option>
          <option value="douyin">üá®üá≥ Douyin</option>
        </select>
        <button id="btnFetch" class="btn-primary">
          <span id="btnText">Download</span>
        </button>
      </div>

      <div id="previewArea" class="preview-area"></div>
      
      <button id="debugToggle" class="debug-toggle" style="display:none">üîß Show Debug Info</button>
      <pre id="debug" style="display:none">{}</pre>
    </div>
  </div>

<script>
/* CONFIG */
const API_BASE = "https://api.ferdev.my.id/downloader";
const API_KEY = "key-Nara";

/* Proxy servers for CORS bypass */
const PROXIES = [
  "https://corsproxy.io/?",
  "https://api.allorigins.win/raw?url=",
];

/* DOM Elements */
const inputUrl = document.getElementById('inputUrl');
const platformSel = document.getElementById('platform');
const btnFetch = document.getElementById('btnFetch');
const btnText = document.getElementById('btnText');
const previewArea = document.getElementById('previewArea');
const debugEl = document.getElementById('debug');
const debugToggle = document.getElementById('debugToggle');

/* Event Listeners */
btnFetch.addEventListener('click', mainFetch);
inputUrl.addEventListener('keydown', e => { if(e.key === 'Enter') mainFetch(); });
debugToggle.addEventListener('click', () => {
  debugEl.style.display = debugEl.style.display === 'none' ? 'block' : 'none';
  debugToggle.textContent = debugEl.style.display === 'none' ? 'üîß Show Debug Info' : 'üîß Hide Debug Info';
});

/* Platform Detection */
function detectPlatformByUrl(url) {
  if(!url) return 'auto';
  url = url.toLowerCase();
  
  if(url.includes('youtube.com') || url.includes('youtu.be')) {
    return 'ytmp4'; // Default to video
  }
  if(url.includes('tiktok.com') || url.includes('vt.tiktok')) return 'tiktok';
  if(url.includes('instagram.com')) return 'instagram';
  if(url.includes('facebook.com') || url.includes('fb.')) return 'facebook';
  if(url.includes('pinterest') || url.includes('pin.it')) return 'pinterest';
  if(url.includes('terabox')) return 'terabox';
  if(url.includes('drive.google')) return 'gdrive';
  if(url.includes('douyin') || url.includes('iesdouyin')) return 'douyin';
  
  return 'auto';
}

/* URL Collection and Categorization */
function collectUrls(obj, urls = []) {
  if(!obj) return urls;
  
  if(typeof obj === 'string') {
    const matches = obj.match(/https?:\/\/[^\s"'<>]+/g);
    if(matches) urls.push(...matches);
  } else if(Array.isArray(obj)) {
    obj.forEach(item => collectUrls(item, urls));
  } else if(typeof obj === 'object') {
    Object.values(obj).forEach(val => collectUrls(val, urls));
  }
  
  return urls;
}

function categorizeUrls(urls = []) {
  const unique = [...new Set(urls.map(u => (u || '').trim()).filter(Boolean))];
  
  const patterns = {
    video: /\.(mp4|webm|mov|mkv|m4v|avi|flv|wmv|3gp)(\?|$|#)/i,
    audio: /\.(mp3|m4a|wav|aac|ogg|opus|flac)(\?|$|#)/i,
    image: /\.(jpe?g|png|gif|webp|bmp|svg|ico)(\?|$|#)/i,
    m3u8: /\.m3u8(\?|$|#)/i
  };
  
  const categorized = {
    videos: [],
    audios: [],
    images: [],
    m3u8: [],
    others: []
  };
  
  unique.forEach(url => {
    // Clean URL
    url = url.replace(/&amp;/g, '&').replace(/\\u0026/g, '&');
    
    // Check by extension or URL pattern
    if(patterns.video.test(url) || 
       url.includes('/video/') || 
       url.includes('video.') ||
       url.includes('fbcdn.net/v/') ||
       (url.includes('googlevideo.com') && !url.includes('audio'))) {
      categorized.videos.push(url);
    } else if(patterns.m3u8.test(url)) {
      categorized.m3u8.push(url);
    } else if(patterns.audio.test(url) || 
              url.includes('/audio/') || 
              url.includes('audio.') ||
              (url.includes('googlevideo.com') && url.includes('audio'))) {
      categorized.audios.push(url);
    } else if(patterns.image.test(url) || 
              url.includes('/image/') || 
              url.includes('/photo')) {
      categorized.images.push(url);
    } else {
      // Check for video indicators without extension
      if(url.includes('fbcdn') || 
         url.includes('instagram') && url.includes('/v/') ||
         url.includes('stream') ||
         url.includes('video')) {
        categorized.videos.push(url);
      } else {
        categorized.others.push(url);
      }
    }
  });
  
  return categorized;
}

function pickBestVideo(videos = []) {
  if(!videos.length) return null;
  
  const scored = videos.map(url => {
    let score = 0;
    
    // Resolution scoring
    if(url.includes('1080') || url.includes('1920')) score += 100;
    else if(url.includes('720') || url.includes('1280')) score += 80;
    else if(url.includes('480') || url.includes('854')) score += 60;
    else if(url.includes('360') || url.includes('640')) score += 40;
    else if(url.includes('240')) score += 20;
    
    // Quality indicators
    if(url.includes('hd') || url.includes('HD')) score += 50;
    if(url.includes('high')) score += 30;
    if(url.includes('medium')) score -= 10;
    if(url.includes('low')) score -= 30;
    
    // Format preference
    if(url.includes('.mp4')) score += 15;
    if(url.includes('.webm')) score += 5;
    
    // YouTube specific
    if(url.includes('googlevideo.com')) {
      if(url.includes('itag=22')) score += 90; // 720p MP4
      if(url.includes('itag=18')) score += 70; // 360p MP4
      if(url.includes('itag=37')) score += 100; // 1080p MP4
    }
    
    return { url, score };
  });
  
  scored.sort((a, b) => b.score - a.score);
  return scored[0].url;
}

/* Main Fetch Function */
async function mainFetch() {
  const userUrl = inputUrl.value.trim();
  let platform = platformSel.value;
  
  if(!userUrl) {
    showError('Please enter a valid URL');
    return;
  }
  
  if(platform === 'auto') {
    platform = detectPlatformByUrl(userUrl);
  }
  
  // Update button state
  btnFetch.disabled = true;
  btnText.innerHTML = '<span class="loading"></span>';
  previewArea.innerHTML = '<div class="success-msg">üîç Fetching media information...</div>';
  debugToggle.style.display = 'block';
  
  try {
    const apiUrl = `${API_BASE}/${platform}?link=${encodeURIComponent(userUrl)}&apikey=${API_KEY}`;
    const response = await fetch(apiUrl);
    
    let json;
    try {
      json = await response.json();
    } catch(e) {
      json = { raw: await response.text() };
    }
    
    // Update debug info
    debugEl.textContent = JSON.stringify(json, null, 2);
    
    // Collect all URLs from response
    let allUrls = collectUrls(json);
    
    // Special handling for specific API structures
    if(json && json.data) {
      const data = json.data;
      
      // YouTube specific
      if(platform === 'ytmp4' || platform === 'ytmp3') {
        if(data.video) allUrls.push(data.video);
        if(data.audio) allUrls.push(data.audio);
        if(data.url) allUrls.push(data.url);
        if(data.download) allUrls.push(data.download);
        if(data.link) allUrls.push(data.link);
      }
      
      // Check common fields
      ['video', 'videos', 'videoUrl', 'video_url', 'media', 'mediaUrl',
       'download', 'downloadUrl', 'dlink', 'url', 'link', 'file',
       'mp4', 'hd', 'sd', 'source'].forEach(key => {
        if(data[key]) {
          if(typeof data[key] === 'string') {
            allUrls.push(data[key]);
          } else if(Array.isArray(data[key])) {
            allUrls = allUrls.concat(data[key].map(item => 
              typeof item === 'string' ? item : item.url || item.link || item.download
            ).filter(Boolean));
          } else if(typeof data[key] === 'object' && data[key].url) {
            allUrls.push(data[key].url);
          }
        }
      });
    }
    
    // Also check result field
    if(json && json.result) {
      allUrls = allUrls.concat(collectUrls(json.result));
    }
    
    // Categorize URLs
    const categorized = categorizeUrls(allUrls);
    
    // Select best media based on platform
    let chosenUrl = null;
    let mediaType = 'video';
    
    if(platform === 'ytmp3' && categorized.audios.length > 0) {
      chosenUrl = categorized.audios[0];
      mediaType = 'audio';
    } else if(categorized.videos.length > 0) {
      chosenUrl = pickBestVideo(categorized.videos);
      mediaType = 'video';
    } else if(categorized.m3u8.length > 0) {
      chosenUrl = categorized.m3u8[0];
      mediaType = 'video';
    } else if(categorized.audios.length > 0) {
      chosenUrl = categorized.audios[0];
      mediaType = 'audio';
    } else if(categorized.others.length > 0) {
      chosenUrl = categorized.others[0];
      mediaType = 'unknown';
    } else if(categorized.images.length > 0) {
      chosenUrl = categorized.images[0];
      mediaType = 'image';
    }
    
    if(!chosenUrl) {
      showError('No downloadable media found in the response');
      debugToggle.textContent = 'üîß Show Debug Info (check for errors)';
      return;
    }
    
    // Clean URL
    chosenUrl = chosenUrl.replace(/&amp;/g, '&').replace(/\\u0026/g, '&');
    
    // Extract metadata
    const metadata = extractMetadata(json);
    
    // Render the UI
    renderMediaUI(chosenUrl, metadata, categorized, mediaType, platform);
    
  } catch(error) {
    console.error('Fetch error:', error);
    showError(`Failed to fetch media: ${error.message}`);
  } finally {
    btnFetch.disabled = false;
    btnText.textContent = 'Download';
  }
}

function extractMetadata(json) {
  const meta = {
    title: null,
    thumbnail: null,
    duration: null,
    size: null,
    author: null
  };
  
  if(json && json.data) {
    const data = json.data;
    meta.title = data.title || data.description || data.caption || null;
    meta.thumbnail = data.thumbnail || data.thumb || data.cover || null;
    meta.duration = data.duration || null;
    meta.size = data.size || data.filesize || null;
    meta.author = data.author || data.username || data.channel || null;
  }
  
  return meta;
}

function renderMediaUI(url, metadata, categorized, mediaType, platform) {
  previewArea.innerHTML = '';
  
  // Create preview card
  const card = document.createElement('div');
  card.className = 'preview-card';
  
  // Title
  if(metadata.title) {
    const title = document.createElement('h2');
    title.className = 'media-title';
    title.textContent = metadata.title;
    card.appendChild(title);
  }
  
  // Info badges
  const infoDiv = document.createElement('div');
  infoDiv.className = 'media-info';
  
  if(metadata.author) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `üë§ ${metadata.author}`;
    infoDiv.appendChild(badge);
  }
  
  if(metadata.duration) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `‚è± ${metadata.duration}`;
    infoDiv.appendChild(badge);
  }
  
  if(metadata.size) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `üì¶ ${formatBytes(metadata.size)}`;
    infoDiv.appendChild(badge);
  }
  
  const typeBadge = document.createElement('span');
  typeBadge.className = 'info-badge';
  typeBadge.textContent = `üìé ${mediaType.toUpperCase()}`;
  infoDiv.appendChild(typeBadge);
  
  if(infoDiv.children.length > 0) {
    card.appendChild(infoDiv);
  }
  
  // Thumbnail
  if(metadata.thumbnail) {
    const thumb = document.createElement('img');
    thumb.src = metadata.thumbnail;
    thumb.style.maxHeight = '200px';
    thumb.style.width = 'auto';
    thumb.style.marginBottom = '1rem';
    card.appendChild(thumb);
  }
  
  // Media preview
  const previewContainer = document.createElement('div');
  previewContainer.style.marginTop = '1rem';
  
  if(mediaType === 'video' || mediaType === 'unknown') {
    const video = document.createElement('video');
    video.controls = true;
    video.preload = 'metadata';
    previewContainer.appendChild(video);
    
    // Try to set video source with proxy fallback
    tryVideoSource(video, url);
  } else if(mediaType === 'audio') {
    const audio = document.createElement('audio');
    audio.controls = true;
    audio.preload = 'metadata';
    previewContainer.appendChild(audio);
    tryAudioSource(audio, url);
  } else if(mediaType === 'image') {
    const img = document.createElement('img');
    img.src = url;
    previewContainer.appendChild(img);
  }
  
  card.appendChild(previewContainer);
  
  // Download section
  const downloadSection = document.createElement('div');
  downloadSection.className = 'download-section';
  
  // Main download button
  const downloadBtn = document.createElement('button');
  downloadBtn.className = 'btn-download';
  downloadBtn.innerHTML = '‚¨áÔ∏è Download File';
  downloadBtn.onclick = () => downloadMedia(url, metadata, mediaType, platform);
  downloadSection.appendChild(downloadBtn);
  
  // Direct link button
  const directBtn = document.createElement('a');
  directBtn.className = 'btn-alt';
  directBtn.href = url;
  directBtn.target = '_blank';
  directBtn.textContent = 'üîó Open Direct Link';
  downloadSection.appendChild(directBtn);
  
  // Alternative quality options
  if(categorized.videos.length > 1) {
    categorized.videos.forEach((videoUrl, index) => {
      if(videoUrl !== url) {
        const altBtn = document.createElement('button');
        altBtn.className = 'btn-alt';
        altBtn.textContent = `üìπ Alternative ${index + 1}`;
        altBtn.onclick = () => renderMediaUI(videoUrl, metadata, categorized, 'video', platform);
        downloadSection.appendChild(altBtn);
      }
    });
  }
  
  card.appendChild(downloadSection);
  previewArea.appendChild(card);
  
  // URL list (collapsed by default)
  if(categorized) {
    displayUrlList(categorized);
  }
}

function displayUrlList(categorized) {
  const listContainer = document.createElement('div');
  listContainer.className = 'url-list';
  listContainer.innerHTML = '<div style="font-weight:bold;margin-bottom:10px">üîç Found URLs:</div>';
  
  if(categorized.videos.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Videos (${categorized.videos.length})`;
    listContainer.appendChild(cat);
    
    categorized.videos.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item video';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }
  
  if(categorized.audios.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Audio (${categorized.audios.length})`;
    listContainer.appendChild(cat);
    
    categorized.audios.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item audio';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }
  
  if(categorized.images.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Images (${categorized.images.length})`;
    listContainer.appendChild(cat);
    
    categorized.images.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item image';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }
  
  previewArea.appendChild(listContainer);
}

async function tryVideoSource(videoElement, url) {
  // First try direct URL
  videoElement.src = url;
  
  // If CORS fails, try with proxy
  videoElement.onerror = async () => {
    for(const proxy of PROXIES) {
      try {
        videoElement.src = proxy + encodeURIComponent(url);
        await new Promise((resolve, reject) => {
          videoElement.onloadedmetadata = resolve;
          videoElement.onerror = reject;
          setTimeout(reject, 3000);
        });
        return; // Success
      } catch(e) {
        continue;
      }
    }
  };
}

async function tryAudioSource(audioElement, url) {
  audioElement.src = url;
  
  audioElement.onerror = async () => {
    for(const proxy of PROXIES) {
      try {
        audioElement.src = proxy + encodeURIComponent(url);
        await new Promise((resolve, reject) => {
          audioElement.onloadedmetadata = resolve;
          audioElement.onerror = reject;
          setTimeout(reject, 3000);
        });
        return;
      } catch(e) {
        continue;
      }
    }
  };
}

async function downloadMedia(url, metadata, mediaType, platform) {
  const progressDiv = document.createElement('div');
  progressDiv.className = 'success-msg';
  progressDiv.innerHTML = 'üì• Starting download...';
  previewArea.appendChild(progressDiv);
  
  try {
    // Determine filename with proper extension
    let filename = metadata.title || 'download';
    filename = filename.replace(/[^a-z0-9]/gi, '_').replace(/__+/g, '_');
    
    // Add proper extension based on media type and platform
    let extension = '';
    if(platform === 'ytmp3' || mediaType === 'audio') {
      extension = '.mp3';
    } else if(platform === 'ytmp4' || mediaType === 'video') {
      extension = '.mp4';
    } else if(mediaType === 'image') {
      extension = '.jpg';
    } else {
      // Try to detect from URL
      const urlLower = url.toLowerCase();
      if(urlLower.includes('.mp4')) extension = '.mp4';
      else if(urlLower.includes('.mp3')) extension = '.mp3';
      else if(urlLower.includes('.webm')) extension = '.webm';
      else if(urlLower.includes('.m4a')) extension = '.m4a';
      else extension = '.mp4'; // Default to mp4
    }
    
    if(!filename.endsWith(extension)) {
      filename += extension;
    }
    
    // Try to download with progress
    const blob = await downloadWithProgress(url, (progress) => {
      progressDiv.innerHTML = `üì• Downloading... ${progress}%`;
    });
    
    // Create download link
    const downloadUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = downloadUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    // Clean up
    setTimeout(() => URL.revokeObjectURL(downloadUrl), 30000);
    
    progressDiv.innerHTML = '‚úÖ Download complete!';
    setTimeout(() => progressDiv.remove(), 3000);
    
  } catch(error) {
    console.error('Download error:', error);
    progressDiv.className = 'error-msg';
    progressDiv.innerHTML = `‚ùå Download failed. Try the direct link instead.`;
  }
}

async function downloadWithProgress(url, onProgress) {
  let lastError = null;
  
  // Try with proxies first, then direct
  const attempts = [...PROXIES.map(p => p + encodeURIComponent(url)), url];
  
  for(const attemptUrl of attempts) {
    try {
      const response = await fetch(attemptUrl);
      
      if(!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      // Get content length
      const contentLength = response.headers.get('content-length');
      const total = parseInt(contentLength, 10);
      
      // If no body stream support, just get blob
      if(!response.body) {
        return await response.blob();
      }
      
      // Read with progress
      const reader = response.body.getReader();
      const chunks = [];
      let received = 0;
      
      while(true) {
        const { done, value } = await reader.read();
        
        if(done) break;
        
        chunks.push(value);
        received += value.length;
        
        if(onProgress && total) {
          onProgress(Math.round((received / total) * 100));
        }
      }
      
      // Combine chunks into blob
      const blob = new Blob(chunks);
      return blob;
      
    } catch(error) {
      lastError = error;
      continue;
    }
  }
  
  throw lastError || new Error('All download attempts failed');
}

function showError(message) {
  previewArea.innerHTML = `<div class="error-msg">‚ùå ${message}</div>`;
}

function formatBytes(bytes) {
  if(!bytes || bytes === 0) return 'Unknown size';
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
}

function truncateUrl(url) {
  if(url.length > 80) {
    return url.substring(0, 80) + '...';
  }
  return url;
}

// Auto-focus on input
inputUrl.focus();
</script>
</body>
</html>