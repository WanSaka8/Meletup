<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>üå∏ OTAKU DOWNLOADER üå∏ - Ultimate Media Downloader</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap');
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    --primary: #ff6b9d;
    --primary-dark: #e91e63;
    --secondary: #4fc3f7;
    --accent: #ffd54f;
    --success: #66bb6a;
    --danger: #ef5350;
    --warning: #ffab40;
    --dark: #1a1a2e;
    --card: #16213e;
    --text: #ffffff;
    --muted: #b0bec5;
    --border: rgba(255, 107, 157, 0.3);
    --anime-pink: #ffb3d1;
    --anime-blue: #b3d9ff;
    --anime-purple: #d1b3ff;
  }

  body {
    min-height: 100vh;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #ff6b9d 100%);
    font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    color: var(--text);
    position: relative;
    overflow-x: hidden;
  }

  /* Animated background with anime particles */
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      radial-gradient(circle at 10% 20%, rgba(255, 182, 209, 0.4) 0%, transparent 50%),
      radial-gradient(circle at 90% 80%, rgba(179, 217, 255, 0.4) 0%, transparent 50%),
      radial-gradient(circle at 50% 50%, rgba(255, 213, 79, 0.3) 0%, transparent 50%);
    animation: float 15s ease-in-out infinite;
    pointer-events: none;
  }

  /* Sakura petals animation */
  body::after {
    content: 'üå∏ üå∫ ‚ú® üå∏ üå∫ ‚ú® üå∏ üå∫ ‚ú® üå∏ üå∫ ‚ú® üå∏ üå∫ ‚ú®';
    position: fixed;
    top: -10px;
    left: 0;
    right: 0;
    font-size: 20px;
    white-space: nowrap;
    animation: sakura 20s linear infinite;
    pointer-events: none;
    z-index: 1;
    opacity: 0.6;
  }

  @keyframes float {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    33% { transform: translate(-30px, -30px) rotate(2deg); }
    66% { transform: translate(30px, -20px) rotate(-2deg); }
  }

  @keyframes sakura {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
    position: relative;
    z-index: 2;
  }

  .header {
    text-align: center;
    margin-bottom: 3rem;
    animation: slideDown 0.8s ease-out;
    position: relative;
  }

  /* Anime character decoration */
  .header::before {
    content: '';
    position: absolute;
    top: -50px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 100px;
    background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23ff6b9d" opacity="0.3"/><circle cx="35" cy="40" r="8" fill="%23fff"/><circle cx="65" cy="40" r="8" fill="%23fff"/><circle cx="35" cy="40" r="4" fill="%23000"/><circle cx="65" cy="40" r="4" fill="%23000"/><path d="M30 65 Q50 75 70 65" stroke="%23fff" stroke-width="3" fill="none"/></svg>') no-repeat center;
    background-size: contain;
    animation: bounce 2s ease-in-out infinite;
  }

  @keyframes bounce {
    0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
    40% { transform: translateX(-50%) translateY(-10px); }
    60% { transform: translateX(-50%) translateY(-5px); }
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  h1 {
    font-size: 3.5rem;
    font-weight: 900;
    background: linear-gradient(135deg, #fff 0%, #ff6b9d 30%, #4fc3f7 60%, #ffd54f 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 0.5rem;
    text-shadow: 0 0 80px rgba(255, 107, 157, 0.6);
    animation: kawaii-glow 3s ease-in-out infinite;
    font-family: 'Nunito', sans-serif;
    letter-spacing: 2px;
  }

  @keyframes kawaii-glow {
    0%, 100% { 
      filter: brightness(1) drop-shadow(0 0 10px rgba(255, 107, 157, 0.5)); 
      transform: scale(1);
    }
    50% { 
      filter: brightness(1.3) drop-shadow(0 0 20px rgba(255, 107, 157, 0.8)); 
      transform: scale(1.02);
    }
  }

  .subtitle {
    color: var(--anime-pink);
    font-size: 1.2rem;
    opacity: 0.9;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }

  .main-card {
    background: linear-gradient(145deg, rgba(22, 33, 62, 0.95), rgba(26, 26, 46, 0.95));
    backdrop-filter: blur(25px);
    border-radius: 30px;
    padding: 2.5rem;
    box-shadow: 
      0 25px 80px rgba(0, 0, 0, 0.4),
      0 0 0 2px var(--border),
      inset 0 1px 0 rgba(255, 255, 255, 0.1),
      0 0 50px rgba(255, 107, 157, 0.2);
    animation: fadeInUp 0.8s ease-out 0.2s both;
    position: relative;
    overflow: hidden;
  }

  /* Anime sparkles decoration */
  .main-card::before {
    content: '‚ú® ‚≠ê üí´ ‚≠ê ‚ú® üí´ ‚≠ê ‚ú® üí´ ‚≠ê ‚ú® üí´ ‚≠ê';
    position: absolute;
    top: -5px;
    left: 0;
    right: 0;
    font-size: 16px;
    text-align: center;
    animation: sparkle 8s linear infinite;
    opacity: 0.7;
  }

  .main-card::after {
    content: '';
    position: absolute;
    top: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><g fill="%23ff6b9d" opacity="0.6"><circle cx="50" cy="30" r="25"/><ellipse cx="35" cy="55" rx="15" ry="25"/><ellipse cx="65" cy="55" rx="15" ry="25"/><circle cx="40" cy="25" r="3" fill="%23fff"/><circle cx="60" cy="25" r="3" fill="%23fff"/><path d="M42 35 Q50 40 58 35" stroke="%23fff" stroke-width="2" fill="none"/></g></svg>') no-repeat center;
    background-size: contain;
    animation: float 6s ease-in-out infinite;
  }

  @keyframes sparkle {
    0% { transform: translateX(-10px); opacity: 0.7; }
    50% { transform: translateX(10px); opacity: 1; }
    100% { transform: translateX(-10px); opacity: 0.7; }
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(40px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .input-group {
    display: flex;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
    position: relative;
    z-index: 3;
  }

  .input-wrapper {
    flex: 1;
    min-width: 250px;
    position: relative;
  }

  input {
    width: 100%;
    padding: 1.2rem 1.8rem;
    background: linear-gradient(145deg, rgba(15, 15, 35, 0.8), rgba(22, 33, 62, 0.8));
    border: 2px solid var(--border);
    border-radius: 20px;
    color: var(--text);
    font-size: 1rem;
    font-weight: 500;
    transition: all 0.3s ease;
    font-family: 'Nunito', sans-serif;
  }

  input:focus {
    outline: none;
    border-color: var(--primary);
    background: linear-gradient(145deg, rgba(15, 15, 35, 0.9), rgba(22, 33, 62, 0.9));
    box-shadow: 0 0 0 4px rgba(255, 107, 157, 0.2), 0 0 20px rgba(255, 107, 157, 0.3);
    transform: translateY(-2px);
  }

  input::placeholder {
    color: var(--anime-pink);
    opacity: 0.7;
  }

  select {
    padding: 1.2rem 1.8rem;
    background: linear-gradient(145deg, rgba(15, 15, 35, 0.8), rgba(22, 33, 62, 0.8));
    border: 2px solid var(--border);
    border-radius: 20px;
    color: var(--text);
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 180px;
    font-family: 'Nunito', sans-serif;
  }

  select:hover {
    border-color: var(--primary);
    background: linear-gradient(145deg, rgba(15, 15, 35, 0.9), rgba(22, 33, 62, 0.9));
    transform: translateY(-2px);
  }

  select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 4px rgba(255, 107, 157, 0.2);
  }

  .btn-primary {
    padding: 1.2rem 2.5rem;
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 50%, var(--secondary) 100%);
    border: none;
    border-radius: 20px;
    color: white;
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    min-width: 150px;
    font-family: 'Nunito', sans-serif;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .btn-primary::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transition: left 0.6s ease;
  }

  .btn-primary:hover::before {
    left: 100%;
  }

  .btn-primary:hover {
    transform: translateY(-3px) scale(1.02);
    box-shadow: 0 15px 40px rgba(255, 107, 157, 0.5);
  }

  .btn-primary:active {
    transform: translateY(-1px) scale(1);
  }

  .btn-primary:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  .preview-area {
    margin-top: 2rem;
    animation: fadeIn 0.5s ease;
    position: relative;
    z-index: 3;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .preview-card {
    background: linear-gradient(145deg, rgba(15, 15, 35, 0.6), rgba(22, 33, 62, 0.6));
    border: 2px solid var(--border);
    border-radius: 25px;
    padding: 2rem;
    margin-bottom: 1rem;
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
  }

  .preview-card::before {
    content: 'üíñ';
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 24px;
    animation: heartbeat 2s ease-in-out infinite;
  }

  @keyframes heartbeat {
    0%, 50%, 100% { transform: scale(1); }
    25% { transform: scale(1.1); }
    75% { transform: scale(0.9); }
  }

  .media-title {
    font-size: 1.6rem;
    font-weight: 800;
    margin-bottom: 1rem;
    color: var(--anime-pink);
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }

  .media-info {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .info-badge {
    padding: 0.6rem 1.2rem;
    background: linear-gradient(135deg, rgba(255, 107, 157, 0.3), rgba(79, 195, 247, 0.3));
    border: 2px solid var(--primary);
    border-radius: 25px;
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--anime-pink);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  }

  video, audio {
    width: 100%;
    max-width: 100%;
    border-radius: 20px;
    background: #000;
    margin: 1rem 0;
    border: 3px solid var(--primary);
    box-shadow: 0 10px 30px rgba(255, 107, 157, 0.3);
  }

  img {
    max-width: 100%;
    border-radius: 20px;
    margin: 1rem 0;
    border: 3px solid var(--primary);
    box-shadow: 0 10px 30px rgba(255, 107, 157, 0.3);
  }

  .download-section {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  .btn-download {
    padding: 1rem 2rem;
    background: linear-gradient(135deg, var(--success) 0%, #43a047 100%);
    border: none;
    border-radius: 20px;
    color: white;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-family: 'Nunito', sans-serif;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .btn-download::before {
    content: '‚¨áÔ∏è';
    font-size: 1.2em;
  }

  .btn-download:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 15px 40px rgba(102, 187, 106, 0.4);
  }

  .btn-alt {
    padding: 1rem 2rem;
    background: linear-gradient(135deg, rgba(255, 107, 157, 0.2), rgba(79, 195, 247, 0.2));
    border: 2px solid var(--primary);
    border-radius: 20px;
    color: var(--primary);
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    font-family: 'Nunito', sans-serif;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .btn-alt:hover {
    background: linear-gradient(135deg, rgba(255, 107, 157, 0.3), rgba(79, 195, 247, 0.3));
    transform: translateY(-3px) scale(1.05);
  }

  .loading {
    display: inline-block;
    width: 24px;
    height: 24px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top-color: var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .error-msg {
    padding: 1.2rem;
    background: linear-gradient(135deg, rgba(239, 67, 80, 0.2), rgba(229, 57, 53, 0.2));
    border: 2px solid var(--danger);
    border-radius: 20px;
    color: var(--danger);
    margin: 1rem 0;
    font-weight: 600;
    position: relative;
  }

  .error-msg::before {
    content: 'üò¢';
    position: absolute;
    top: 50%;
    left: 15px;
    transform: translateY(-50%);
    font-size: 1.5em;
  }

  .error-msg {
    padding-left: 60px;
  }

  .success-msg {
    padding: 1.2rem;
    background: linear-gradient(135deg, rgba(102, 187, 106, 0.2), rgba(76, 175, 80, 0.2));
    border: 2px solid var(--success);
    border-radius: 20px;
    color: var(--success);
    margin: 1rem 0;
    font-weight: 600;
    position: relative;
  }

  .success-msg::before {
    content: 'üéâ';
    position: absolute;
    top: 50%;
    left: 15px;
    transform: translateY(-50%);
    font-size: 1.5em;
  }

  .success-msg {
    padding-left: 60px;
  }

  /* Anime character images */
  .anime-character {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 120px;
    height: 120px;
    background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><g transform="translate(100,100)"><circle r="80" fill="%23ffb3d1" opacity="0.8"/><circle cx="0" cy="-10" r="60" fill="%23ffe0e6"/><circle cx="-20" cy="-25" r="8" fill="%23000"/><circle cx="20" cy="-25" r="8" fill="%23000"/><circle cx="-20" cy="-25" r="4" fill="%23fff"/><circle cx="20" cy="-25" r="4" fill="%23fff"/><ellipse cx="0" cy="-5" rx="3" ry="5" fill="%23ff6b9d"/><path d="M-15 5 Q0 15 15 5" stroke="%23ff6b9d" stroke-width="3" fill="none"/><circle cx="-25" cy="-10" r="15" fill="%23ff6b9d" opacity="0.6"/><circle cx="25" cy="-10" r="15" fill="%23ff6b9d" opacity="0.6"/></g></svg>') no-repeat center;
    background-size: contain;
    animation: float 4s ease-in-out infinite;
    pointer-events: none;
    z-index: 1000;
  }

  @media (max-width: 768px) {
    .anime-character {
      display: none;
    }
    
    h1 {
      font-size: 2.5rem;
    }
    
    .container {
      padding: 1rem;
    }
    
    .main-card {
      padding: 1.5rem;
    }
    
    .input-group {
      flex-direction: column;
    }
    
    select {
      min-width: 100%;
    }
  }

  /* Additional kawaii elements */
  .kawaii-decoration {
    position: absolute;
    font-size: 2rem;
    animation: float 3s ease-in-out infinite;
    pointer-events: none;
    opacity: 0.7;
  }

  .kawaii-1 { top: 15%; left: 10%; animation-delay: 0s; }
  .kawaii-2 { top: 25%; right: 15%; animation-delay: 1s; }
  .kawaii-3 { bottom: 30%; left: 5%; animation-delay: 2s; }
  .kawaii-4 { bottom: 20%; right: 10%; animation-delay: 1.5s; }
</style>
</head>
<body>
  <!-- Kawaii decorations -->
  <div class="kawaii-decoration kawaii-1">üåü</div>
  <div class="kawaii-decoration kawaii-2">üíñ</div>
  <div class="kawaii-decoration kawaii-3">üå∏</div>
  <div class="kawaii-decoration kawaii-4">‚ú®</div>
  <div class="anime-character"></div>

  <div class="container">
    <div class="header">
      <div class="header-mascot"></div>
      <h1>üå∏ OTAKU DOWNLOADER üå∏</h1>
      <p class="subtitle">‚ú® Kawaii Media Downloader ~ YouTube, TikTok, Instagram & More ‚ú®</p>
    </div>

    <div class="main-card">
      <div class="input-group">
        <div class="input-wrapper">
          <input 
            id="inputUrl" 
            type="url" 
            placeholder="üîó Paste your kawaii link here~ (YouTube, TikTok, Instagram, Facebook, etc.)"
            autocomplete="off"
          />
        </div>
        <select id="platform">
          <option value="auto">üîç Auto Detect</option>
          <option value="ytmp4">üìπ YouTube Video</option>
          <option value="ytmp3">üéµ YouTube Audio</option>
          <option value="tiktok">üé≠ TikTok</option>
          <option value="instagram">üì∑ Instagram</option>
          <option value="facebook">üë§ Facebook</option>
          <option value="pinterest">üìå Pinterest</option>
          <option value="terabox">‚òÅÔ∏è Terabox</option>
          <option value="gdrive">üìÅ Google Drive</option>
          <option value="douyin">üá®üá≥ Douyin</option>
          <option value="bilibili">üà∂ Bilibili</option>
        </select>
        <button id="btnFetch" class="btn-primary">
          <span id="btnText">üí´ Download</span>
        </button>
      </div>

      <div id="previewArea" class="preview-area"></div>

      <button id="debugToggle" class="debug-toggle" style="display:none">üîß Show Debug Info</button>
      <pre id="debug" style="display:none">{}</pre>
    </div>
  </div>
<script>
/* CONFIG */
const API_BASE = "https://api.ferdev.my.id/downloader";
const API_KEY = "key-Nara";

/* Proxy servers for CORS bypass */
const PROXIES = [
  "https://corsproxy.io/?",
  "https://api.allorigins.win/raw?url=",
];

/* DOM Elements */
const inputUrl = document.getElementById('inputUrl');
const platformSel = document.getElementById('platform');
const btnFetch = document.getElementById('btnFetch');
const btnText = document.getElementById('btnText');
const previewArea = document.getElementById('previewArea');
const debugEl = document.getElementById('debug');
const debugToggle = document.getElementById('debugToggle');

/* Event Listeners */
btnFetch.addEventListener('click', mainFetch);
inputUrl.addEventListener('keydown', e => { if(e.key === 'Enter') mainFetch(); });
debugToggle.addEventListener('click', () => {
  debugEl.style.display = debugEl.style.display === 'none' ? 'block' : 'none';
  debugToggle.textContent = debugEl.style.display === 'none' ? 'üîß Show Debug Info' : 'üîß Hide Debug Info';
});

/* Platform Detection */
function detectPlatformByUrl(url) {
  if(!url) return 'auto';
  url = url.toLowerCase();

  if(url.includes('youtube.com') || url.includes('youtu.be')) {
    return 'ytmp4'; // Default to video
  }
  if(url.includes('tiktok.com') || url.includes('vt.tiktok')) return 'tiktok';
  if(url.includes('instagram.com')) return 'instagram';
  if(url.includes('facebook.com') || url.includes('fb.')) return 'facebook';
  if(url.includes('pinterest') || url.includes('pin.it')) return 'pinterest';
  if(url.includes('terabox')) return 'terabox';
  if(url.includes('drive.google')) return 'gdrive';
  if(url.includes('douyin') || url.includes('iesdouyin')) return 'douyin';
  if(url.includes('bilibili.com') || url.includes('bilibili.tv') || url.includes('b23.tv')) return 'bilibili';

  return 'auto';
}

/* URL Collection and Categorization */
function collectUrls(obj, urls = []) {
  if(!obj) return urls;

  if(typeof obj === 'string') {
    const matches = obj.match(/https?:\/\/[^\s"'<>]+/g);
    if(matches) urls.push(...matches);
  } else if(Array.isArray(obj)) {
    obj.forEach(item => collectUrls(item, urls));
  } else if(typeof obj === 'object') {
    Object.values(obj).forEach(val => collectUrls(val, urls));
  }

  return urls;
}



function categorizeUrls(urls = []) {
  const unique = [...new Set(urls.map(u => (u || '').trim()).filter(Boolean))];

  const patterns = {
    video: /\.(mp4|webm|mov|mkv|m4v|avi|flv|wmv|3gp)(\?|$|#)/i,
    audio: /\.(mp3|m4a|wav|aac|ogg|opus|flac)(\?|$|#)/i,
    image: /\.(jpe?g|png|gif|webp|bmp|svg|ico)(\?|$|#)/i,
    m3u8: /\.m3u8(\?|$|#)/i
  };

  const categorized = {
    videos: [],
    audios: [],
    images: [],
    m3u8: [],
    others: []
  };

  unique.forEach(url => {
    url = url.replace(/&amp;/g, '&').replace(/\u0026/g, '&');

    // Prefer exact extension matches first (auto-detect)
    if (patterns.image.test(url)) {
      categorized.images.push(url);
      return;
    }
    if (patterns.video.test(url)) {
      categorized.videos.push(url);
      return;
    }
    if (patterns.audio.test(url)) {
      categorized.audios.push(url);
      return;
    }
    if (patterns.m3u8.test(url)) {
      categorized.m3u8.push(url);
      return;
    }

    // Heuristics for known hosts when no extension present
    const lower = url.toLowerCase();
    if (lower.includes('googlevideo.com') || lower.includes('fbcdn') || lower.includes('cdn') || lower.includes('video')) {
      categorized.videos.push(url);
    } if (lower.includes('instagram') && (lower.includes('scontent') || lower.includes('cdninstagram') || lower.includes('instagram-static') || lower.includes('/vp/'))) {
      // try to decide if instagram link is image or video
      if (patterns.image.test(url) || lower.includes('/s640x640') || lower.includes('/s320x320') || lower.includes('=jpg') || lower.includes('format=jpg') || lower.includes('jpg')) {
        categorized.images.push(url);
      } else if (lower.includes('/vp/') || lower.includes('/v/') || lower.includes('.mp4') || lower.includes('video')) {
        categorized.videos.push(url);
      } else {
        categorized.others.push(url);
      }
    } else {
      categorized.others.push(url);
    }
  });

  return categorized;
}

// Extra Instagram Image Fix
function fixInstagramImageUrl(url) {
  try {
    // Instagram image links sometimes redirect to HTML preview
    // Force direct download by appending ?dl=1 if missing
    if (url.includes('instagram') && !url.includes('?dl=1') && !url.includes('&dl=1')) {
      return url + (url.includes('?') ? '&dl=1' : '?dl=1');
    }
  } catch (e) {}
  return url;
}



function pickBestVideo(videos = []) {
  if(!videos.length) return null;

  const scored = videos.map(url => {
    let score = 0;

    // Resolution scoring
    if(url.includes('1080') || url.includes('1920')) score += 100;
    else if(url.includes('720') || url.includes('1280')) score += 80;
    else if(url.includes('480') || url.includes('854')) score += 60;
    else if(url.includes('360') || url.includes('640')) score += 40;
    else if(url.includes('240')) score += 20;

    // Quality indicators
    if(url.includes('hd') || url.includes('HD')) score += 50;
    if(url.includes('high')) score += 30;
    if(url.includes('medium')) score -= 10;
    if(url.includes('low')) score -= 30;

    // Format preference
    if(url.includes('.mp4')) score += 15;
    if(url.includes('.webm')) score += 5;

    // YouTube specific
    if(url.includes('googlevideo.com')) {
      if(url.includes('itag=22')) score += 90; // 720p MP4
      if(url.includes('itag=18')) score += 70; // 360p MP4
      if(url.includes('itag=37')) score += 100; // 1080p MP4
    }

    return { url, score };
  });

  scored.sort((a, b) => b.score - a.score);
  return scored[0].url;
}

/* Main Fetch Function */
async function mainFetch() {
  const userUrl = inputUrl.value.trim();
  let platform = platformSel.value;

  if(!userUrl) {
    showError('Please enter a valid URL');
    return;
  }

  if(platform === 'auto') {
    platform = detectPlatformByUrl(userUrl);
  }

  // Update button state
  btnFetch.disabled = true;
  btnText.innerHTML = '<span class="loading"></span>';
  previewArea.innerHTML = '<div class="success-msg">üîç Sabar lagi di proses cik...</div>';
  debugToggle.style.display = 'block';

  try {
    const apiUrl = `${API_BASE}/${platform}?link=${encodeURIComponent(userUrl)}&apikey=${API_KEY}`;
    const response = await fetch(apiUrl);

    let json;
    try {
      json = await response.json();
    } catch(e) {
      json = { raw: await response.text() };
    }

    // Update debug info
    debugEl.textContent = JSON.stringify(json, null, 2);


    // Collect all URLs from response
    let allUrls = collectUrls(json);

    if(json && json.data) {
      const data = json.data;

      // YouTube specific handling: support multiple possible fields
      if(platform === 'ytmp4' || platform === 'ytmp3') {
        // common direct fields
        ['video','audio','url','download','link','source','file','mp4','hd','sd'].forEach(k => {
          if(data[k]) {
            if(typeof data[k] === 'string') allUrls.push(data[k]);
            else if(Array.isArray(data[k])) allUrls = allUrls.concat(data[k].map(i => typeof i === 'string' ? i : i.url || i.link).filter(Boolean));
            else if(typeof data[k] === 'object' && data[k].url) allUrls.push(data[k].url);
          }
        });

        // array of links/formats
        if(data.links && Array.isArray(data.links)) {
          allUrls = allUrls.concat(data.links.map(i => i.url || i.link || i.download).filter(Boolean));
        }
        if(data.formats && Array.isArray(data.formats)) {
          allUrls = allUrls.concat(data.formats.map(i => i.url || i.link || i.download).filter(Boolean));
        }
      }

      // Facebook specific handling: prefer hd/sd video fields, avoid thumbnails
      if(platform === 'facebook') {
        if(data.hd && typeof data.hd === 'string') allUrls.push(data.hd);
        if(data.sd && typeof data.sd === 'string') allUrls.push(data.sd);

        // sometimes facebook returns an array or object of files
        ['video','videos','file','download','url','link'].forEach(k => {
          if(data[k]) {
            if(typeof data[k] === 'string') allUrls.push(data[k]);
            else if(Array.isArray(data[k])) allUrls = allUrls.concat(data[k].map(i => typeof i === 'string' ? i : i.url || i.link).filter(Boolean));
            else if(typeof data[k] === 'object' && data[k].url) allUrls.push(data[k].url);
          }
        });

        // audio fallback
        if(data.audio && typeof data.audio === 'string') allUrls.push(data.audio);
      }

      // Generic fields fallback for other platforms
      ['video','videos','videoUrl','video_url','media','mediaUrl','download','downloadUrl','dlink','url','link','file','mp4','hd','sd','source'].forEach(key => {
        if(data[key]) {
          if(typeof data[key] === 'string') {
            allUrls.push(data[key]);
          } else if(Array.isArray(data[key])) {
            allUrls = allUrls.concat(data[key].map(item => 
              typeof item === 'string' ? item : item.url || item.link || item.download
            ).filter(Boolean));
          } else if(typeof data[key] === 'object' && data[key].url) {
            allUrls.push(data[key].url);
          }
        }
      });
    }

    // Categorize URLs
    const categorized = categorizeUrls(allUrls);

    // Select best media based on platform
    let chosenUrl = null;
    let mediaType = 'video';

    // Prefer images for Instagram/Facebook when available
    if ((platform === 'instagram' || platform === 'facebook')) {
      if (categorized.images && categorized.images.length > 1) {
        // multiple images -> render multi UI and exit
        renderMediaMulti(categorized, extractMetadata(json), platform);
        btnFetch.disabled = false;
        btnText.textContent = 'Download';
        return;
      } else if (categorized.images && categorized.images.length === 1) {
        chosenUrl = categorized.images[0];
        mediaType = 'image';
      }
    }


    if(platform === 'ytmp3' && categorized.audios.length > 0) {
      chosenUrl = categorized.audios[0];
      mediaType = 'audio';
    } else if(categorized.videos.length > 0) {
      chosenUrl = pickBestVideo(categorized.videos);
      mediaType = 'video';
    } else if(categorized.m3u8.length > 0) {
      chosenUrl = categorized.m3u8[0];
      mediaType = 'video';
    } else if(categorized.audios.length > 0) {
      chosenUrl = categorized.audios[0];
      mediaType = 'audio';
    } else if(categorized.others.length > 0) {
      chosenUrl = categorized.others[0];
      mediaType = 'unknown';
    } else if(categorized.images.length > 0) {
      chosenUrl = categorized.images[0];
      mediaType = 'image';
    }

    if(!chosenUrl) {
      showError('No downloadable media found in the response');
      debugToggle.textContent = 'üîß Show Debug Info (check for errors)';
      return;
    }

    // Clean URL
    chosenUrl = chosenUrl.replace(/&amp;/g, '&').replace(/\\u0026/g, '&');

    // Extract metadata
    const metadata = extractMetadata(json);

    // Render the UI
    renderMediaUI(chosenUrl, metadata, categorized, mediaType, platform);

  } catch(error) {
    console.error('Fetch error:', error);
    showError(`Failed to fetch media: ${error.message}`);
  } finally {
    btnFetch.disabled = false;
    btnText.textContent = 'Download';
  }
}

function extractMetadata(json) {
  const meta = {
    title: null,
    thumbnail: null,
    duration: null,
    size: null,
    author: null
  };

  if(json && json.data) {
    const data = json.data;
    meta.title = data.title || data.description || data.caption || null;
    meta.thumbnail = data.thumbnail || data.thumb || data.cover || null;
    meta.duration = data.duration || null;
    meta.size = data.size || data.filesize || null;
    meta.author = data.author || data.username || data.channel || null;
  }

  return meta;
}


/* --- START: Enhanced detection + multi-render + Download All --- */

// Try to detect content-type via HEAD request; returns mime or null
async function detectContentType(url) {
  try {
    const resp = await fetch(url, { method: 'HEAD' });
    if(resp && resp.headers) {
      const ct = resp.headers.get('content-type');
      if(ct) return ct.split(';')[0].trim();
    }
  } catch(e) {
    // HEAD may be blocked by CORS; try to fetch small range
    try {
      const r = await fetch(url, { method: 'GET', headers: { Range: 'bytes=0-1023' } });
      const ct = r.headers.get('content-type');
      if(ct) return ct.split(';')[0].trim();
    } catch(err) {
      return null;
    }
  }
  return null;
}

// Determine media type for a given url using extension + content-type fallback

// Determine media type for a given url using extension + content-type fallback
async function determineMediaType(url) {
  const lower = (url || '').toLowerCase();
  // direct extension checks
  if(/\.(jpe?g|png|gif|webp|bmp|svg|ico)(\?|$|#)/i.test(lower)) return 'image';
  if(/\.(mp4|webm|mov|mkv|m4v|avi|flv|wmv|3gp)(\?|$|#)/i.test(lower)) return 'video';
  if(/\.(mp3|m4a|wav|aac|ogg|opus|flac)(\?|$|#)/i.test(lower)) return 'audio';

  // try HEAD to get content-type (may be blocked by CORS)
  const ct = await detectContentType(url);
  if(ct) {
    if(ct.startsWith('image/')) return 'image';
    if(ct.startsWith('video/')) return 'video';
    if(ct.startsWith('audio/')) return 'audio';
  }

  // host-specific hints (only when ct unavailable)
  if(lower.includes('googlevideo.com')) return 'video'; // youtube CDN very likely video/audio
  if(lower.includes('fbcdn.net') && lower.includes('.mp4')) return 'video';
  if(lower.includes('instagram') && lower.includes('vp')) return 'video'; // instagram video pattern
  if(lower.includes('instagram') && lower.includes('scontent')) return 'image'; // instagram images often scontent

  // couldn't determine
  return 'unknown';
}


// Render multiple media items and provide Download All
async function renderMediaMulti(categorized, metadata, platform) {
  previewArea.innerHTML = '';
  const card = document.createElement('div');
  card.className = 'preview-card';

  if(metadata && metadata.title) {
    const title = document.createElement('h2');
    title.className = 'media-title';
    title.textContent = metadata.title;
    card.appendChild(title);
  }

  // gather all urls ordered: images then videos then audios then others
  const all = [].concat(categorized.images, categorized.videos, categorized.audios, categorized.m3u8, categorized.others);

  // Resolve exact types for ambiguous URLs
  const resolved = [];
  for(const u of all) {
    const t = await determineMediaType(u);
    resolved.push({ url: u, type: t });
  }

  // create container for items
  const itemsWrap = document.createElement('div');
  itemsWrap.style.display = 'grid';
  itemsWrap.style.gridTemplateColumns = 'repeat(auto-fit,minmax(240px,1fr))';
  itemsWrap.style.gap = '12px';

  // create download all button
  const downloadAllBtn = document.createElement('button');
  downloadAllBtn.className = 'btn-download';
  downloadAllBtn.textContent = '‚¨áÔ∏è Download All';
  downloadAllBtn.style.marginBottom = '10px';

  // when clicked, attempt to zip using JSZip; fallback to sequential downloads
  downloadAllBtn.onclick = async () => {
    downloadAllBtn.disabled = true;
    downloadAllBtn.textContent = 'üîÑ Preparing...';
    // try load JSZip dynamically
    let JSZip = null;
    try {
      if(!window.JSZip) {
        await new Promise((res, rej) => {
          const s = document.createElement('script');
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
          s.onload = () => res();
          s.onerror = () => rej(new Error('Failed to load JSZip'));
          document.head.appendChild(s);
        });
      }
      JSZip = window.JSZip;
    } catch(e) {
      JSZip = null;
    }

    if(JSZip) {
      try {
        const zip = new JSZip();
        // fetch each file as blob and add to zip
        for(const [i, it] of resolved.entries()) {
          try {
            const r = await fetch(it.url);
            if(!r.ok) throw new Error('HTTP ' + r.status);
            const blob = await r.blob();
            // decide extension
            let ext = '.bin';
            if(it.type === 'image') ext = '.jpg';
            else if(it.type === 'video') ext = '.mp4';
            else if(it.type === 'audio') ext = '.mp3';
            zip.file(('file_' + (i+1) + ext), blob);
          } catch(err) {
            console.warn('skip', it.url, err);
          }
        }
        const content = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = (metadata && metadata.title ? metadata.title.replace(/[^a-z0-9]/gi,'_') : 'download') + '.zip';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        downloadAllBtn.textContent = '‚úÖ Downloaded ZIP';
        setTimeout(() => downloadAllBtn.textContent = '‚¨áÔ∏è Download All', 3000);
      } catch(e) {
        console.warn('zip failed', e);
        // fallback to sequential downloads
        for(const [i, it] of resolved.entries()) {
          triggerDownload(it.url, metadata, i);
        }
        downloadAllBtn.textContent = '‚¨áÔ∏è Downloading...';
      }
    } else {
      // no JSZip, fallback to sequential downloads
      for(const [i, it] of resolved.entries()) {
        triggerDownload(it.url, metadata, i);
      }
      downloadAllBtn.textContent = '‚¨áÔ∏è Downloading...';
    }

    setTimeout(() => { downloadAllBtn.disabled = false; downloadAllBtn.textContent = '‚¨áÔ∏è Download All'; }, 3000);
  };

  card.appendChild(downloadAllBtn);

  // Render each item with its own download button
  resolved.forEach((it, idx) => {
    const box = document.createElement('div');
    box.style.background = 'rgba(0,0,0,0.2)';
    box.style.padding = '8px';
    box.style.borderRadius = '8px';
    box.style.display = 'flex';
    box.style.flexDirection = 'column';
    box.style.alignItems = 'stretch';

    const info = document.createElement('div');
    info.style.fontSize = '13px';
    info.style.marginBottom = '6px';
    info.textContent = `${it.type.toUpperCase()} ‚Ä¢ ${truncateUrl(it.url)}`;
    box.appendChild(info);

    if(it.type === 'image') {
      const img = document.createElement('img');
      img.src = it.url;
      img.style.maxHeight = '200px';
      img.style.objectFit = 'cover';
      box.appendChild(img);
    } else if(it.type === 'video') {
      const vid = document.createElement('video');
      vid.controls = true;
      vid.preload = 'metadata';
      tryVideoSource(vid, it.url);
      box.appendChild(vid);
    } else if(it.type === 'audio') {
      const aud = document.createElement('audio');
      aud.controls = true;
      aud.preload = 'metadata';
      tryAudioSource(aud, it.url);
      box.appendChild(aud);
    } else {
      const link = document.createElement('a');
      link.href = it.url;
      link.target = '_blank';
      link.textContent = 'Open file';
      box.appendChild(link);
    }

    const dl = document.createElement('button');
    dl.className = 'btn-alt';
    dl.style.marginTop = '8px';
    dl.textContent = '‚¨áÔ∏è Download';
    dl.onclick = () => triggerDownload(it.url, metadata, idx);
    box.appendChild(dl);

    itemsWrap.appendChild(box);
  });

  card.appendChild(itemsWrap);
  previewArea.appendChild(card);
}

// helper: trigger download of a single url, attempt CORS-friendly fetch then blob link



async function triggerDownload(url, metadata, idx) {
  try {
    url = fixInstagramImageUrl(url); // apply Instagram fix

    const resp = await fetch(url, { method: 'GET' });
    if (!resp.ok) throw new Error('HTTP ' + resp.status);

    const ct = resp.headers.get('content-type') || '';
    if (ct.includes('text/html')) {
      // HTML preview, not direct media ‚Üí open in new tab instead
      const a = document.createElement('a');
      a.href = url;
      a.target = '_blank';
      document.body.appendChild(a);
      a.click();
      a.remove();
      return;
    }

    const blob = await resp.blob();
    let ext = '';
    if (ct.startsWith('image/')) {
      ext = '.' + ct.split('/')[1].split(';')[0];
    } else if (ct.startsWith('video/')) {
      ext = '.' + ct.split('/')[1].split(';')[0];
    } else if (ct.startsWith('audio/')) {
      ext = '.' + ct.split('/')[1].split(';')[0];
    } else {
      const m = url.match(/\.([a-zA-Z0-9]+)(\?|$)/);
      ext = m ? '.' + m[1] : '.jpg';
    }

    let filename = (metadata && metadata.title)
      ? metadata.title.replace(/[^a-z0-9]/gi, '_')
      : 'file';
    filename += '_' + (idx + 1) + ext;

    const dlUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = dlUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(dlUrl), 30000);
  } catch (e) {
    // fallback open direct
    const a = document.createElement('a');
    a.href = url;
    a.target = '_blank';
    document.body.appendChild(a);
    a.click();
    a.remove();
  }
}
/* --- END/* --- END: Enhanced detection + multi-render + Download All --- */
function renderMediaUI(url, metadata, categorized, mediaType, platform) {
  // If multiple images found, use multi renderer
  if (categorized && categorized.images && categorized.images.length > 1) {
    return renderMediaMulti(categorized, metadata, platform);
  }

  previewArea.innerHTML = '';

  // Create preview card
  const card = document.createElement('div');
  card.className = 'preview-card';

  // Title
  if(metadata.title) {
    const title = document.createElement('h2');
    title.className = 'media-title';
    title.textContent = metadata.title;
    card.appendChild(title);
  }

  // Info badges
  const infoDiv = document.createElement('div');
  infoDiv.className = 'media-info';

  if(metadata.author) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `üë§ ${metadata.author}`;
    infoDiv.appendChild(badge);
  }

  if(metadata.duration) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `‚è± ${metadata.duration}`;
    infoDiv.appendChild(badge);
  }

  if(metadata.size) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `üì¶ ${formatBytes(metadata.size)}`;
    infoDiv.appendChild(badge);
  }

  const typeBadge = document.createElement('span');
  typeBadge.className = 'info-badge';
  typeBadge.textContent = `üìé ${mediaType.toUpperCase()}`;
  infoDiv.appendChild(typeBadge);

  if(infoDiv.children.length > 0) {
    card.appendChild(infoDiv);
  }

  // Thumbnail
  if(metadata.thumbnail) {
    const thumb = document.createElement('img');
    thumb.src = metadata.thumbnail;
    thumb.style.maxHeight = '200px';
    thumb.style.width = 'auto';
    thumb.style.marginBottom = '1rem';
    card.appendChild(thumb);
  }

  // Media preview
  const previewContainer = document.createElement('div');
  previewContainer.style.marginTop = '1rem';

  if(mediaType === 'video' || mediaType === 'unknown') {
    const video = document.createElement('video');
    video.controls = true;
    video.preload = 'metadata';
    previewContainer.appendChild(video);

    // Try to set video source with proxy fallback
    tryVideoSource(video, url);
  } else if(mediaType === 'audio') {
    const audio = document.createElement('audio');
    audio.controls = true;
    audio.preload = 'metadata';
    previewContainer.appendChild(audio);
    tryAudioSource(audio, url);
  } else if(mediaType === 'image') {
    const img = document.createElement('img');
    img.src = url;
    previewContainer.appendChild(img);
  }

  card.appendChild(previewContainer);

  // Download section
  const downloadSection = document.createElement('div');
  downloadSection.className = 'download-section';

  // Main download button
  const downloadBtn = document.createElement('button');
  downloadBtn.className = 'btn-download';
  downloadBtn.innerHTML = '‚¨áÔ∏è Download File';
  downloadBtn.onclick = () => downloadMedia(url, metadata, mediaType, platform);
  downloadSection.appendChild(downloadBtn);

  // Direct link button
  const directBtn = document.createElement('a');
  directBtn.className = 'btn-alt';
  directBtn.href = url;
  directBtn.target = '_blank';
  directBtn.textContent = 'üîó Open Direct Link';
  downloadSection.appendChild(directBtn);

  // Alternative quality options
  if(categorized.videos.length > 1) {
    categorized.videos.forEach((videoUrl, index) => {
      if(videoUrl !== url) {
        const altBtn = document.createElement('button');
        altBtn.className = 'btn-alt';
        altBtn.textContent = `üìπ Alternative ${index + 1}`;
        altBtn.onclick = () => renderMediaUI(videoUrl, metadata, categorized, 'video', platform);
        downloadSection.appendChild(altBtn);
      }
    });
  }

  card.appendChild(downloadSection);
  previewArea.appendChild(card);

  // URL list (collapsed by default)
  if(categorized) {
    displayUrlList(categorized);
  }
}

function displayUrlList(categorized) {
  const listContainer = document.createElement('div');
  listContainer.className = 'url-list';
  listContainer.innerHTML = '<div style="font-weight:bold;margin-bottom:10px">üîç Found URLs:</div>';

  if(categorized.videos.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Videos (${categorized.videos.length})`;
    listContainer.appendChild(cat);

    categorized.videos.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item video';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }

  if(categorized.audios.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Audio (${categorized.audios.length})`;
    listContainer.appendChild(cat);

    categorized.audios.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item audio';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }

  if(categorized.images.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Images (${categorized.images.length})`;
    listContainer.appendChild(cat);

    categorized.images.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item image';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }

  previewArea.appendChild(listContainer);
}

async function tryVideoSource(videoElement, url) {
  // First try direct URL
  videoElement.src = url;

  // If CORS fails, try with proxy
  videoElement.onerror = async () => {
    for(const proxy of PROXIES) {
      try {
        videoElement.src = proxy + encodeURIComponent(url);
        await new Promise((resolve, reject) => {
          videoElement.onloadedmetadata = resolve;
          videoElement.onerror = reject;
          setTimeout(reject, 3000);
        });
        return; // Success
      } catch(e) {
        continue;
      }
    }
  };
}

async function tryAudioSource(audioElement, url) {
  audioElement.src = url;

  audioElement.onerror = async () => {
    for(const proxy of PROXIES) {
      try {
        audioElement.src = proxy + encodeURIComponent(url);
        await new Promise((resolve, reject) => {
          audioElement.onloadedmetadata = resolve;
          audioElement.onerror = reject;
          setTimeout(reject, 3000);
        });
        return;
      } catch(e) {
        continue;
      }
    }
  };
}


async function downloadMedia(url, metadata, mediaType, platform) {
  const progressDiv = document.createElement('div');
  progressDiv.className = 'success-msg';
  progressDiv.innerHTML = 'üì• Starting download...';
  previewArea.appendChild(progressDiv);

  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const blob = await resp.blob();

    // Deteksi ekstensi file
    const ct = resp.headers.get('content-type') || blob.type || '';
    let extension = '';
    if (ct.startsWith('image/')) extension = '.' + ct.split('/')[1].split(';')[0];
    else if (ct.startsWith('video/')) extension = '.' + ct.split('/')[1].split(';')[0];
    else if (ct.startsWith('audio/')) extension = '.' + ct.split('/')[1].split(';')[0];
    else {
      const m = url.match(/\.([a-zA-Z0-9]+)(\?|$)/);
      extension = m ? '.' + m[1] : (mediaType === 'image' ? '.jpg' : '.mp4');
    }

    let filename = metadata.title || 'download';
    filename = filename.replace(/[^a-z0-9]/gi, '_').replace(/__+/g, '_');
    if (!filename.endsWith(extension)) filename += extension;

    const downloadUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = downloadUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(downloadUrl), 30000);

    progressDiv.innerHTML = '‚úÖ Download complete!';
    setTimeout(() => progressDiv.remove(), 3000);
  } catch (error) {
    console.error('Download error:', error);
    progressDiv.className = 'error-msg';
    progressDiv.innerHTML = '‚ùå Download failed. Try the direct link instead.';
  }
}
async function downloadWithProgress(url, onProgress) {
  let lastError = null;

  // Try with proxies first, then direct
  const attempts = [...PROXIES.map(p => p + encodeURIComponent(url)), url];

  for(const attemptUrl of attempts) {
    try {
      const response = await fetch(attemptUrl);

      if(!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      // Get content length
      const contentLength = response.headers.get('content-length');
      const total = parseInt(contentLength, 10);

      // If no body stream support, just get blob
      if(!response.body) {
        return await response.blob();
      }

      // Read with progress
      const reader = response.body.getReader();
      const chunks = [];
      let received = 0;

      while(true) {
        const { done, value } = await reader.read();

        if(done) break;

        chunks.push(value);
        received += value.length;

        if(onProgress && total) {
          onProgress(Math.round((received / total) * 100));
        }
      }

      // Combine chunks into blob
      const blob = new Blob(chunks);
      return blob;

    } catch(error) {
      lastError = error;
      continue;
    }
  }

  throw lastError || new Error('All download attempts failed');
}

function showError(message) {
  previewArea.innerHTML = `<div class="error-msg">‚ùå ${message}</div>`;
}

function formatBytes(bytes) {
  if(!bytes || bytes === 0) return 'Unknown size';
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
}

function truncateUrl(url) {
  if(url.length > 80) {
    return url.substring(0, 80) + '...';
  }
  return url;
}

// Auto-focus on input
inputUrl.focus();
</script>
</body>
</html>
