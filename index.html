<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AKU NAK MELETUP - Ultimate Downloader</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    --primary: #8b5cf6;
    --primary-dark: #7c3aed;
    --secondary: #06b6d4;
    --success: #10b981;
    --danger: #ef4444;
    --warning: #f59e0b;
    --dark: #0f0f23;
    --card: #1a1a2e;
    --text: #e4e4e7;
    --muted: #71717a;
    --border: rgba(139, 92, 246, 0.2);
  }

  body {
    min-height: 100vh;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    color: var(--text);
    position: relative;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      radial-gradient(circle at 20% 80%, rgba(139, 92, 246, 0.3) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(6, 182, 212, 0.3) 0%, transparent 50%),
      radial-gradient(circle at 40% 40%, rgba(236, 72, 153, 0.2) 0%, transparent 50%);
    animation: float 20s ease-in-out infinite;
    pointer-events: none;
  }

  @keyframes float {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    33% { transform: translate(-20px, -20px) rotate(1deg); }
    66% { transform: translate(20px, -10px) rotate(-1deg); }
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
    position: relative;
    z-index: 1;
  }

  .header {
    text-align: center;
    margin-bottom: 3rem;
    animation: slideDown 0.8s ease-out;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  h1 {
    font-size: 3.5rem;
    font-weight: 900;
    background: linear-gradient(135deg, #fff 0%, #8b5cf6 50%, #06b6d4 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 0.5rem;
    text-shadow: 0 0 80px rgba(139, 92, 246, 0.5);
    animation: glow 3s ease-in-out infinite;
  }

  @keyframes glow {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
  }

  .subtitle {
    color: var(--muted);
    font-size: 1.1rem;
    opacity: 0.9;
  }

  .main-card {
    background: rgba(26, 26, 46, 0.95);
    backdrop-filter: blur(20px);
    border-radius: 24px;
    padding: 2rem;
    box-shadow: 
      0 20px 60px rgba(0, 0, 0, 0.3),
      0 0 0 1px var(--border),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
    animation: fadeInUp 0.8s ease-out 0.2s both;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .input-group {
    display: flex;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
  }

  .input-wrapper {
    flex: 1;
    min-width: 250px;
    position: relative;
  }

  input {
    width: 100%;
    padding: 1rem 1.5rem;
    background: rgba(15, 15, 35, 0.6);
    border: 2px solid var(--border);
    border-radius: 12px;
    color: var(--text);
    font-size: 1rem;
    transition: all 0.3s ease;
  }

  input:focus {
    outline: none;
    border-color: var(--primary);
    background: rgba(15, 15, 35, 0.8);
    box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.1);
  }

  input::placeholder {
    color: var(--muted);
  }

  select {
    padding: 1rem 1.5rem;
    background: rgba(15, 15, 35, 0.6);
    border: 2px solid var(--border);
    border-radius: 12px;
    color: var(--text);
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 150px;
  }

  select:hover {
    border-color: var(--primary);
    background: rgba(15, 15, 35, 0.8);
  }

  select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.1);
  }

  .btn-primary {
    padding: 1rem 2rem;
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
    border: none;
    border-radius: 12px;
    color: white;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    min-width: 120px;
  }

  .btn-primary::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s ease;
  }

  .btn-primary:hover::before {
    left: 100%;
  }

  .btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
  }

  .btn-primary:active {
    transform: translateY(0);
  }

  .btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .preview-area {
    margin-top: 2rem;
    animation: fadeIn 0.5s ease;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .preview-card {
    background: rgba(15, 15, 35, 0.4);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 1.5rem;
    margin-bottom: 1rem;
  }

  .media-title {
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 1rem;
    color: var(--text);
  }

  .media-info {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .info-badge {
    padding: 0.5rem 1rem;
    background: rgba(139, 92, 246, 0.2);
    border: 1px solid var(--primary);
    border-radius: 20px;
    font-size: 0.9rem;
    color: var(--primary);
  }

  video, audio {
    width: 100%;
    max-width: 100%;
    border-radius: 12px;
    background: #000;
    margin: 1rem 0;
  }

  img {
    max-width: 100%;
    border-radius: 12px;
    margin: 1rem 0;
  }

  .url-list {
    background: rgba(15, 15, 35, 0.6);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1rem;
    margin: 1rem 0;
    max-height: 300px;
    overflow-y: auto;
  }

  .url-list::-webkit-scrollbar {
    width: 8px;
  }

  .url-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
  }

  .url-list::-webkit-scrollbar-thumb {
    background: var(--primary);
    border-radius: 4px;
  }

  .url-category {
    font-weight: 600;
    color: var(--text);
    margin: 0.5rem 0;
    padding-bottom: 0.25rem;
    border-bottom: 1px solid var(--border);
  }

  .url-item {
    font-size: 0.85rem;
    color: var(--muted);
    padding: 0.25rem 0;
    word-break: break-all;
    transition: color 0.2s ease;
  }

  .url-item:hover {
    color: var(--text);
  }

  .url-item.video { color: var(--success); }
  .url-item.audio { color: var(--secondary); }
  .url-item.image { color: var(--warning); }

  .download-section {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
    flex-wrap: wrap;
  }

  .btn-download {
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
    border: none;
    border-radius: 10px;
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
  }

  .btn-download:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
  }

  .btn-alt {
    padding: 0.75rem 1.5rem;
    background: rgba(139, 92, 246, 0.2);
    border: 1px solid var(--primary);
    border-radius: 10px;
    color: var(--primary);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
  }

  .btn-alt:hover {
    background: rgba(139, 92, 246, 0.3);
    transform: translateY(-2px);
  }

  .loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .progress-bar {
    width: 100%;
    height: 6px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
    overflow: hidden;
    margin: 1rem 0;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--secondary));
    border-radius: 3px;
    transition: width 0.3s ease;
    animation: shimmer 2s linear infinite;
  }

  @keyframes shimmer {
    0% { background-position: -200% center; }
    100% { background-position: 200% center; }
  }

  .error-msg {
    padding: 1rem;
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid var(--danger);
    border-radius: 10px;
    color: var(--danger);
    margin: 1rem 0;
  }

  .success-msg {
    padding: 1rem;
    background: rgba(16, 185, 129, 0.1);
    border: 1px solid var(--success);
    border-radius: 10px;
    color: var(--success);
    margin: 1rem 0;
  }

  pre {
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 1rem;
    color: var(--muted);
    font-size: 0.85rem;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 300px;
    overflow-y: auto;
    margin-top: 1rem;
  }

  .debug-toggle {
    margin-top: 1rem;
    padding: 0.5rem 1rem;
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--muted);
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .debug-toggle:hover {
    background: rgba(0, 0, 0, 0.3);
    color: var(--text);
  }
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>AKU NAK MELETUP</h1>
      <p class="subtitle">Ultimate Media Downloader - YouTube, TikTok, Instagram & More</p>
    </div>

    <div class="main-card">
      <div class="input-group">
        <div class="input-wrapper">
          <input 
            id="inputUrl" 
            type="url" 
            placeholder="Paste your link here (YouTube, TikTok, Instagram, Facebook, etc.)"
            autocomplete="off"
          />
        </div>
        <select id="platform">
          <option value="auto">üîç Auto Detect</option>
          <option value="ytmp4">üìπ YouTube Video</option>
          <option value="ytmp3">üéµ YouTube Audio</option>
          <option value="tiktok">üé≠ TikTok</option>
          <option value="instagram">üì∑ Instagram</option>
          <option value="facebook">üë§ Facebook</option>
          <option value="pinterest">üìå Pinterest</option>
          <option value="terabox">‚òÅÔ∏è Terabox</option>
          <option value="gdrive">üìÅ Google Drive</option>
          <option value="douyin">üá®üá≥ Douyin</option>
        </select>
        <button id="btnFetch" class="btn-primary">
          <span id="btnText">Download</span>
        </button>
      </div>

      <div id="previewArea" class="preview-area"></div>
      
      <button id="debugToggle" class="debug-toggle" style="display:none">üîß Show Debug Info</button>
      <pre id="debug" style="display:none">{}</pre>
    </div>
  </div>

<script>
/* CONFIG */
const API_BASE = "https://api.ferdev.my.id/downloader";
const API_KEY = "key-Nara";

/* Proxy servers for CORS bypass */
const PROXIES = [
  "https://corsproxy.io/?",
  "https://api.allorigins.win/raw?url=",
];

/* DOM Elements */
const inputUrl = document.getElementById('inputUrl');
const platformSel = document.getElementById('platform');
const btnFetch = document.getElementById('btnFetch');
const btnText = document.getElementById('btnText');
const previewArea = document.getElementById('previewArea');
const debugEl = document.getElementById('debug');
const debugToggle = document.getElementById('debugToggle');

/* Event Listeners */
btnFetch.addEventListener('click', mainFetch);
inputUrl.addEventListener('keydown', e => { if(e.key === 'Enter') mainFetch(); });
debugToggle.addEventListener('click', () => {
  debugEl.style.display = debugEl.style.display === 'none' ? 'block' : 'none';
  debugToggle.textContent = debugEl.style.display === 'none' ? 'üîß Show Debug Info' : 'üîß Hide Debug Info';
});

/* Platform Detection */
function detectPlatformByUrl(url) {
  if(!url) return 'auto';
  url = url.toLowerCase();
  
  if(url.includes('youtube.com') || url.includes('youtu.be')) {
    return 'ytmp4'; // Default to video
  }
  if(url.includes('tiktok.com') || url.includes('vt.tiktok')) return 'tiktok';
  if(url.includes('instagram.com')) return 'instagram';
  if(url.includes('facebook.com') || url.includes('fb.')) return 'facebook';
  if(url.includes('pinterest') || url.includes('pin.it')) return 'pinterest';
  if(url.includes('terabox')) return 'terabox';
  if(url.includes('drive.google')) return 'gdrive';
  if(url.includes('douyin') || url.includes('iesdouyin')) return 'douyin';
  
  return 'auto';
}

/* URL Collection and Categorization */
function collectUrls(obj, urls = []) {
  if(!obj) return urls;
  
  if(typeof obj === 'string') {
    const matches = obj.match(/https?:\/\/[^\s"'<>]+/g);
    if(matches) urls.push(...matches);
  } else if(Array.isArray(obj)) {
    obj.forEach(item => collectUrls(item, urls));
  } else if(typeof obj === 'object') {
    Object.values(obj).forEach(val => collectUrls(val, urls));
  }
  
  return urls;
}


function categorizeUrls(urls = []) {
  const unique = [...new Set(urls.map(u => (u || '').trim()).filter(Boolean))];

  const patterns = {
    video: /\.(mp4|webm|mov|mkv|m4v|avi|flv|wmv|3gp)(\?|$|#)/i,
    audio: /\.(mp3|m4a|wav|aac|ogg|opus|flac)(\?|$|#)/i,
    image: /\.(jpe?g|png|gif|webp|bmp|svg|ico)(\?|$|#)/i,
    m3u8: /\.m3u8(\?|$|#)/i
  };

  const categorized = {
    videos: [],
    audios: [],
    images: [],
    m3u8: [],
    others: []
  };

  unique.forEach(url => {
    url = url.replace(/&amp;/g, '&').replace(/\u0026/g, '&');

    // Prefer exact extension matches first (auto-detect)
    if (patterns.image.test(url)) {
      categorized.images.push(url);
      return;
    }
    if (patterns.video.test(url)) {
      categorized.videos.push(url);
      return;
    }
    if (patterns.audio.test(url)) {
      categorized.audios.push(url);
      return;
    }
    if (patterns.m3u8.test(url)) {
      categorized.m3u8.push(url);
      return;
    }

    // Heuristics for known hosts when no extension present
    const lower = url.toLowerCase();
    if (lower.includes('googlevideo.com') || lower.includes('fbcdn') || lower.includes('cdn') || lower.includes('video')) {
      categorized.videos.push(url);
    } if (lower.includes('instagram') && (lower.includes('scontent') || lower.includes('cdninstagram') || lower.includes('instagram-static') || lower.includes('/vp/'))) {
      // try to decide if instagram link is image or video
      if (patterns.image.test(url) || lower.includes('/s640x640') || lower.includes('/s320x320') || lower.includes('=jpg') || lower.includes('format=jpg') || lower.includes('jpg')) {
        categorized.images.push(url);
      } else if (lower.includes('/vp/') || lower.includes('/v/') || lower.includes('.mp4') || lower.includes('video')) {
        categorized.videos.push(url);
      } else {
        categorized.others.push(url);
      }
    } else {
      categorized.others.push(url);
    }
  });

  return categorized;
}


function pickBestVideo(videos = []) {
  if(!videos.length) return null;
  
  const scored = videos.map(url => {
    let score = 0;
    
    // Resolution scoring
    if(url.includes('1080') || url.includes('1920')) score += 100;
    else if(url.includes('720') || url.includes('1280')) score += 80;
    else if(url.includes('480') || url.includes('854')) score += 60;
    else if(url.includes('360') || url.includes('640')) score += 40;
    else if(url.includes('240')) score += 20;
    
    // Quality indicators
    if(url.includes('hd') || url.includes('HD')) score += 50;
    if(url.includes('high')) score += 30;
    if(url.includes('medium')) score -= 10;
    if(url.includes('low')) score -= 30;
    
    // Format preference
    if(url.includes('.mp4')) score += 15;
    if(url.includes('.webm')) score += 5;
    
    // YouTube specific
    if(url.includes('googlevideo.com')) {
      if(url.includes('itag=22')) score += 90; // 720p MP4
      if(url.includes('itag=18')) score += 70; // 360p MP4
      if(url.includes('itag=37')) score += 100; // 1080p MP4
    }
    
    return { url, score };
  });
  
  scored.sort((a, b) => b.score - a.score);
  return scored[0].url;
}

/* Main Fetch Function */
async function mainFetch() {
  const userUrl = inputUrl.value.trim();
  let platform = platformSel.value;
  
  if(!userUrl) {
    showError('Please enter a valid URL');
    return;
  }
  
  if(platform === 'auto') {
    platform = detectPlatformByUrl(userUrl);
  }
  
  // Update button state
  btnFetch.disabled = true;
  btnText.innerHTML = '<span class="loading"></span>';
  previewArea.innerHTML = '<div class="success-msg">üîç Sabar lagi di proses cik...</div>';
  debugToggle.style.display = 'block';
  
  try {
    const apiUrl = `${API_BASE}/${platform}?link=${encodeURIComponent(userUrl)}&apikey=${API_KEY}`;
    const response = await fetch(apiUrl);
    
    let json;
    try {
      json = await response.json();
    } catch(e) {
      json = { raw: await response.text() };
    }
    
    // Update debug info
    debugEl.textContent = JSON.stringify(json, null, 2);
    
    
    // Collect all URLs from response
    let allUrls = collectUrls(json);

    if(json && json.data) {
      const data = json.data;

      // YouTube specific handling: support multiple possible fields
      if(platform === 'ytmp4' || platform === 'ytmp3') {
        // common direct fields
        ['video','audio','url','download','link','source','file','mp4','hd','sd'].forEach(k => {
          if(data[k]) {
            if(typeof data[k] === 'string') allUrls.push(data[k]);
            else if(Array.isArray(data[k])) allUrls = allUrls.concat(data[k].map(i => typeof i === 'string' ? i : i.url || i.link).filter(Boolean));
            else if(typeof data[k] === 'object' && data[k].url) allUrls.push(data[k].url);
          }
        });

        // array of links/formats
        if(data.links && Array.isArray(data.links)) {
          allUrls = allUrls.concat(data.links.map(i => i.url || i.link || i.download).filter(Boolean));
        }
        if(data.formats && Array.isArray(data.formats)) {
          allUrls = allUrls.concat(data.formats.map(i => i.url || i.link || i.download).filter(Boolean));
        }
      }

      // Facebook specific handling: prefer hd/sd video fields, avoid thumbnails
      if(platform === 'facebook') {
        if(data.hd && typeof data.hd === 'string') allUrls.push(data.hd);
        if(data.sd && typeof data.sd === 'string') allUrls.push(data.sd);

        // sometimes facebook returns an array or object of files
        ['video','videos','file','download','url','link'].forEach(k => {
          if(data[k]) {
            if(typeof data[k] === 'string') allUrls.push(data[k]);
            else if(Array.isArray(data[k])) allUrls = allUrls.concat(data[k].map(i => typeof i === 'string' ? i : i.url || i.link).filter(Boolean));
            else if(typeof data[k] === 'object' && data[k].url) allUrls.push(data[k].url);
          }
        });

        // audio fallback
        if(data.audio && typeof data.audio === 'string') allUrls.push(data.audio);
      }

      // Generic fields fallback for other platforms
      ['video','videos','videoUrl','video_url','media','mediaUrl','download','downloadUrl','dlink','url','link','file','mp4','hd','sd','source'].forEach(key => {
        if(data[key]) {
          if(typeof data[key] === 'string') {
            allUrls.push(data[key]);
          } else if(Array.isArray(data[key])) {
            allUrls = allUrls.concat(data[key].map(item => 
              typeof item === 'string' ? item : item.url || item.link || item.download
            ).filter(Boolean));
          } else if(typeof data[key] === 'object' && data[key].url) {
            allUrls.push(data[key].url);
          }
        }
      });
    }

    // Categorize URLs
    const categorized = categorizeUrls(allUrls);
    
    // Select best media based on platform
    let chosenUrl = null;
    let mediaType = 'video';

    // Prefer images for Instagram/Facebook when available
    if ((platform === 'instagram' || platform === 'facebook')) {
      if (categorized.images && categorized.images.length > 1) {
        // multiple images -> render multi UI and exit
        renderMediaMulti(categorized, extractMetadata(json), platform);
        btnFetch.disabled = false;
        btnText.textContent = 'Download';
        return;
      } else if (categorized.images && categorized.images.length === 1) {
        chosenUrl = categorized.images[0];
        mediaType = 'image';
      }
    }

    
    if(platform === 'ytmp3' && categorized.audios.length > 0) {
      chosenUrl = categorized.audios[0];
      mediaType = 'audio';
    } else if(categorized.videos.length > 0) {
      chosenUrl = pickBestVideo(categorized.videos);
      mediaType = 'video';
    } else if(categorized.m3u8.length > 0) {
      chosenUrl = categorized.m3u8[0];
      mediaType = 'video';
    } else if(categorized.audios.length > 0) {
      chosenUrl = categorized.audios[0];
      mediaType = 'audio';
    } else if(categorized.others.length > 0) {
      chosenUrl = categorized.others[0];
      mediaType = 'unknown';
    } else if(categorized.images.length > 0) {
      chosenUrl = categorized.images[0];
      mediaType = 'image';
    }
    
    if(!chosenUrl) {
      showError('No downloadable media found in the response');
      debugToggle.textContent = 'üîß Show Debug Info (check for errors)';
      return;
    }
    
    // Clean URL
    chosenUrl = chosenUrl.replace(/&amp;/g, '&').replace(/\\u0026/g, '&');
    
    // Extract metadata
    const metadata = extractMetadata(json);
    
    // Render the UI
    renderMediaUI(chosenUrl, metadata, categorized, mediaType, platform);
    
  } catch(error) {
    console.error('Fetch error:', error);
    showError(`Failed to fetch media: ${error.message}`);
  } finally {
    btnFetch.disabled = false;
    btnText.textContent = 'Download';
  }
}

function extractMetadata(json) {
  const meta = {
    title: null,
    thumbnail: null,
    duration: null,
    size: null,
    author: null
  };
  
  if(json && json.data) {
    const data = json.data;
    meta.title = data.title || data.description || data.caption || null;
    meta.thumbnail = data.thumbnail || data.thumb || data.cover || null;
    meta.duration = data.duration || null;
    meta.size = data.size || data.filesize || null;
    meta.author = data.author || data.username || data.channel || null;
  }
  
  return meta;
}


/* --- START: Enhanced detection + multi-render + Download All --- */

// Try to detect content-type via HEAD request; returns mime or null
async function detectContentType(url) {
  try {
    const resp = await fetch(url, { method: 'HEAD' });
    if(resp && resp.headers) {
      const ct = resp.headers.get('content-type');
      if(ct) return ct.split(';')[0].trim();
    }
  } catch(e) {
    // HEAD may be blocked by CORS; try to fetch small range
    try {
      const r = await fetch(url, { method: 'GET', headers: { Range: 'bytes=0-1023' } });
      const ct = r.headers.get('content-type');
      if(ct) return ct.split(';')[0].trim();
    } catch(err) {
      return null;
    }
  }
  return null;
}

// Determine media type for a given url using extension + content-type fallback

// Determine media type for a given url using extension + content-type fallback
async function determineMediaType(url) {
  const lower = (url || '').toLowerCase();
  // direct extension checks
  if(/\.(jpe?g|png|gif|webp|bmp|svg|ico)(\?|$|#)/i.test(lower)) return 'image';
  if(/\.(mp4|webm|mov|mkv|m4v|avi|flv|wmv|3gp)(\?|$|#)/i.test(lower)) return 'video';
  if(/\.(mp3|m4a|wav|aac|ogg|opus|flac)(\?|$|#)/i.test(lower)) return 'audio';

  // try HEAD to get content-type (may be blocked by CORS)
  const ct = await detectContentType(url);
  if(ct) {
    if(ct.startsWith('image/')) return 'image';
    if(ct.startsWith('video/')) return 'video';
    if(ct.startsWith('audio/')) return 'audio';
  }

  // host-specific hints (only when ct unavailable)
  if(lower.includes('googlevideo.com')) return 'video'; // youtube CDN very likely video/audio
  if(lower.includes('fbcdn.net') && lower.includes('.mp4')) return 'video';
  if(lower.includes('instagram') && lower.includes('vp')) return 'video'; // instagram video pattern
  if(lower.includes('instagram') && lower.includes('scontent')) return 'image'; // instagram images often scontent

  // couldn't determine
  return 'unknown';
}


// Render multiple media items and provide Download All
async function renderMediaMulti(categorized, metadata, platform) {
  previewArea.innerHTML = '';
  const card = document.createElement('div');
  card.className = 'preview-card';

  if(metadata && metadata.title) {
    const title = document.createElement('h2');
    title.className = 'media-title';
    title.textContent = metadata.title;
    card.appendChild(title);
  }

  // gather all urls ordered: images then videos then audios then others
  const all = [].concat(categorized.images, categorized.videos, categorized.audios, categorized.m3u8, categorized.others);

  // Resolve exact types for ambiguous URLs
  const resolved = [];
  for(const u of all) {
    const t = await determineMediaType(u);
    resolved.push({ url: u, type: t });
  }

  // create container for items
  const itemsWrap = document.createElement('div');
  itemsWrap.style.display = 'grid';
  itemsWrap.style.gridTemplateColumns = 'repeat(auto-fit,minmax(240px,1fr))';
  itemsWrap.style.gap = '12px';

  // create download all button
  const downloadAllBtn = document.createElement('button');
  downloadAllBtn.className = 'btn-download';
  downloadAllBtn.textContent = '‚¨áÔ∏è Download All';
  downloadAllBtn.style.marginBottom = '10px';

  // when clicked, attempt to zip using JSZip; fallback to sequential downloads
  downloadAllBtn.onclick = async () => {
    downloadAllBtn.disabled = true;
    downloadAllBtn.textContent = 'üîÑ Preparing...';
    // try load JSZip dynamically
    let JSZip = null;
    try {
      if(!window.JSZip) {
        await new Promise((res, rej) => {
          const s = document.createElement('script');
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
          s.onload = () => res();
          s.onerror = () => rej(new Error('Failed to load JSZip'));
          document.head.appendChild(s);
        });
      }
      JSZip = window.JSZip;
    } catch(e) {
      JSZip = null;
    }

    if(JSZip) {
      try {
        const zip = new JSZip();
        // fetch each file as blob and add to zip
        for(const [i, it] of resolved.entries()) {
          try {
            const r = await fetch(it.url);
            if(!r.ok) throw new Error('HTTP ' + r.status);
            const blob = await r.blob();
            // decide extension
            let ext = '.bin';
            if(it.type === 'image') ext = '.jpg';
            else if(it.type === 'video') ext = '.mp4';
            else if(it.type === 'audio') ext = '.mp3';
            zip.file(('file_' + (i+1) + ext), blob);
          } catch(err) {
            console.warn('skip', it.url, err);
          }
        }
        const content = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = (metadata && metadata.title ? metadata.title.replace(/[^a-z0-9]/gi,'_') : 'download') + '.zip';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        downloadAllBtn.textContent = '‚úÖ Downloaded ZIP';
        setTimeout(() => downloadAllBtn.textContent = '‚¨áÔ∏è Download All', 3000);
      } catch(e) {
        console.warn('zip failed', e);
        // fallback to sequential downloads
        for(const [i, it] of resolved.entries()) {
          triggerDownload(it.url, metadata, i);
        }
        downloadAllBtn.textContent = '‚¨áÔ∏è Downloading...';
      }
    } else {
      // no JSZip, fallback to sequential downloads
      for(const [i, it] of resolved.entries()) {
        triggerDownload(it.url, metadata, i);
      }
      downloadAllBtn.textContent = '‚¨áÔ∏è Downloading...';
    }

    setTimeout(() => { downloadAllBtn.disabled = false; downloadAllBtn.textContent = '‚¨áÔ∏è Download All'; }, 3000);
  };

  card.appendChild(downloadAllBtn);

  // Render each item with its own download button
  resolved.forEach((it, idx) => {
    const box = document.createElement('div');
    box.style.background = 'rgba(0,0,0,0.2)';
    box.style.padding = '8px';
    box.style.borderRadius = '8px';
    box.style.display = 'flex';
    box.style.flexDirection = 'column';
    box.style.alignItems = 'stretch';

    const info = document.createElement('div');
    info.style.fontSize = '13px';
    info.style.marginBottom = '6px';
    info.textContent = `${it.type.toUpperCase()} ‚Ä¢ ${truncateUrl(it.url)}`;
    box.appendChild(info);

    if(it.type === 'image') {
      const img = document.createElement('img');
      img.src = it.url;
      img.style.maxHeight = '200px';
      img.style.objectFit = 'cover';
      box.appendChild(img);
    } else if(it.type === 'video') {
      const vid = document.createElement('video');
      vid.controls = true;
      vid.preload = 'metadata';
      tryVideoSource(vid, it.url);
      box.appendChild(vid);
    } else if(it.type === 'audio') {
      const aud = document.createElement('audio');
      aud.controls = true;
      aud.preload = 'metadata';
      tryAudioSource(aud, it.url);
      box.appendChild(aud);
    } else {
      const link = document.createElement('a');
      link.href = it.url;
      link.target = '_blank';
      link.textContent = 'Open file';
      box.appendChild(link);
    }

    const dl = document.createElement('button');
    dl.className = 'btn-alt';
    dl.style.marginTop = '8px';
    dl.textContent = '‚¨áÔ∏è Download';
    dl.onclick = () => triggerDownload(it.url, metadata, idx);
    box.appendChild(dl);

    itemsWrap.appendChild(box);
  });

  card.appendChild(itemsWrap);
  previewArea.appendChild(card);
}

// helper: trigger download of a single url, attempt CORS-friendly fetch then blob link

async function triggerDownload(url, metadata, idx) {
  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const blob = await resp.blob();

    // Deteksi ekstensi otomatis
    const ct = resp.headers.get('content-type') || blob.type || '';
    let ext = '';
    if (ct.startsWith('image/')) {
      ext = '.' + ct.split('/')[1].split(';')[0];
    } else if (ct.startsWith('video/')) {
      ext = '.' + ct.split('/')[1].split(';')[0];
    } else if (ct.startsWith('audio/')) {
      ext = '.' + ct.split('/')[1].split(';')[0];
    } else {
      const m = url.match(/\.([a-zA-Z0-9]+)(\?|$)/);
      ext = m ? '.' + m[1] : '.jpg';
    }

    let filename = (metadata && metadata.title)
      ? metadata.title.replace(/[^a-z0-9]/gi, '_')
      : 'file';
    filename += '_' + (idx + 1) + ext;

    const dlUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = dlUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(dlUrl), 30000);
  } catch (e) {
    // fallback open direct
    const a = document.createElement('a');
    a.href = url;
    a.target = '_blank';
    document.body.appendChild(a);
    a.click();
    a.remove();
  }
}
/* --- END/* --- END: Enhanced detection + multi-render + Download All --- */
function renderMediaUI(url, metadata, categorized, mediaType, platform) {
  // If multiple images found, use multi renderer
  if (categorized && categorized.images && categorized.images.length > 1) {
    return renderMediaMulti(categorized, metadata, platform);
  }

  previewArea.innerHTML = '';
  
  // Create preview card
  const card = document.createElement('div');
  card.className = 'preview-card';
  
  // Title
  if(metadata.title) {
    const title = document.createElement('h2');
    title.className = 'media-title';
    title.textContent = metadata.title;
    card.appendChild(title);
  }
  
  // Info badges
  const infoDiv = document.createElement('div');
  infoDiv.className = 'media-info';
  
  if(metadata.author) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `üë§ ${metadata.author}`;
    infoDiv.appendChild(badge);
  }
  
  if(metadata.duration) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `‚è± ${metadata.duration}`;
    infoDiv.appendChild(badge);
  }
  
  if(metadata.size) {
    const badge = document.createElement('span');
    badge.className = 'info-badge';
    badge.textContent = `üì¶ ${formatBytes(metadata.size)}`;
    infoDiv.appendChild(badge);
  }
  
  const typeBadge = document.createElement('span');
  typeBadge.className = 'info-badge';
  typeBadge.textContent = `üìé ${mediaType.toUpperCase()}`;
  infoDiv.appendChild(typeBadge);
  
  if(infoDiv.children.length > 0) {
    card.appendChild(infoDiv);
  }
  
  // Thumbnail
  if(metadata.thumbnail) {
    const thumb = document.createElement('img');
    thumb.src = metadata.thumbnail;
    thumb.style.maxHeight = '200px';
    thumb.style.width = 'auto';
    thumb.style.marginBottom = '1rem';
    card.appendChild(thumb);
  }
  
  // Media preview
  const previewContainer = document.createElement('div');
  previewContainer.style.marginTop = '1rem';
  
  if(mediaType === 'video' || mediaType === 'unknown') {
    const video = document.createElement('video');
    video.controls = true;
    video.preload = 'metadata';
    previewContainer.appendChild(video);
    
    // Try to set video source with proxy fallback
    tryVideoSource(video, url);
  } else if(mediaType === 'audio') {
    const audio = document.createElement('audio');
    audio.controls = true;
    audio.preload = 'metadata';
    previewContainer.appendChild(audio);
    tryAudioSource(audio, url);
  } else if(mediaType === 'image') {
    const img = document.createElement('img');
    img.src = url;
    previewContainer.appendChild(img);
  }
  
  card.appendChild(previewContainer);
  
  // Download section
  const downloadSection = document.createElement('div');
  downloadSection.className = 'download-section';
  
  // Main download button
  const downloadBtn = document.createElement('button');
  downloadBtn.className = 'btn-download';
  downloadBtn.innerHTML = '‚¨áÔ∏è Download File';
  downloadBtn.onclick = () => downloadMedia(url, metadata, mediaType, platform);
  downloadSection.appendChild(downloadBtn);
  
  // Direct link button
  const directBtn = document.createElement('a');
  directBtn.className = 'btn-alt';
  directBtn.href = url;
  directBtn.target = '_blank';
  directBtn.textContent = 'üîó Open Direct Link';
  downloadSection.appendChild(directBtn);
  
  // Alternative quality options
  if(categorized.videos.length > 1) {
    categorized.videos.forEach((videoUrl, index) => {
      if(videoUrl !== url) {
        const altBtn = document.createElement('button');
        altBtn.className = 'btn-alt';
        altBtn.textContent = `üìπ Alternative ${index + 1}`;
        altBtn.onclick = () => renderMediaUI(videoUrl, metadata, categorized, 'video', platform);
        downloadSection.appendChild(altBtn);
      }
    });
  }
  
  card.appendChild(downloadSection);
  previewArea.appendChild(card);
  
  // URL list (collapsed by default)
  if(categorized) {
    displayUrlList(categorized);
  }
}

function displayUrlList(categorized) {
  const listContainer = document.createElement('div');
  listContainer.className = 'url-list';
  listContainer.innerHTML = '<div style="font-weight:bold;margin-bottom:10px">üîç Found URLs:</div>';
  
  if(categorized.videos.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Videos (${categorized.videos.length})`;
    listContainer.appendChild(cat);
    
    categorized.videos.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item video';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }
  
  if(categorized.audios.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Audio (${categorized.audios.length})`;
    listContainer.appendChild(cat);
    
    categorized.audios.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item audio';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }
  
  if(categorized.images.length > 0) {
    const cat = document.createElement('div');
    cat.className = 'url-category';
    cat.textContent = `Images (${categorized.images.length})`;
    listContainer.appendChild(cat);
    
    categorized.images.forEach(url => {
      const item = document.createElement('div');
      item.className = 'url-item image';
      item.textContent = `‚Ä¢ ${truncateUrl(url)}`;
      listContainer.appendChild(item);
    });
  }
  
  previewArea.appendChild(listContainer);
}

async function tryVideoSource(videoElement, url) {
  // First try direct URL
  videoElement.src = url;
  
  // If CORS fails, try with proxy
  videoElement.onerror = async () => {
    for(const proxy of PROXIES) {
      try {
        videoElement.src = proxy + encodeURIComponent(url);
        await new Promise((resolve, reject) => {
          videoElement.onloadedmetadata = resolve;
          videoElement.onerror = reject;
          setTimeout(reject, 3000);
        });
        return; // Success
      } catch(e) {
        continue;
      }
    }
  };
}

async function tryAudioSource(audioElement, url) {
  audioElement.src = url;
  
  audioElement.onerror = async () => {
    for(const proxy of PROXIES) {
      try {
        audioElement.src = proxy + encodeURIComponent(url);
        await new Promise((resolve, reject) => {
          audioElement.onloadedmetadata = resolve;
          audioElement.onerror = reject;
          setTimeout(reject, 3000);
        });
        return;
      } catch(e) {
        continue;
      }
    }
  };
}


async function downloadMedia(url, metadata, mediaType, platform) {
  const progressDiv = document.createElement('div');
  progressDiv.className = 'success-msg';
  progressDiv.innerHTML = 'üì• Starting download...';
  previewArea.appendChild(progressDiv);

  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const blob = await resp.blob();

    // Deteksi ekstensi file
    const ct = resp.headers.get('content-type') || blob.type || '';
    let extension = '';
    if (ct.startsWith('image/')) extension = '.' + ct.split('/')[1].split(';')[0];
    else if (ct.startsWith('video/')) extension = '.' + ct.split('/')[1].split(';')[0];
    else if (ct.startsWith('audio/')) extension = '.' + ct.split('/')[1].split(';')[0];
    else {
      const m = url.match(/\.([a-zA-Z0-9]+)(\?|$)/);
      extension = m ? '.' + m[1] : (mediaType === 'image' ? '.jpg' : '.mp4');
    }

    let filename = metadata.title || 'download';
    filename = filename.replace(/[^a-z0-9]/gi, '_').replace(/__+/g, '_');
    if (!filename.endsWith(extension)) filename += extension;

    const downloadUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = downloadUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(downloadUrl), 30000);

    progressDiv.innerHTML = '‚úÖ Download complete!';
    setTimeout(() => progressDiv.remove(), 3000);
  } catch (error) {
    console.error('Download error:', error);
    progressDiv.className = 'error-msg';
    progressDiv.innerHTML = '‚ùå Download failed. Try the direct link instead.';
  }
}
async function downloadWithProgress(url, onProgress) {
  let lastError = null;
  
  // Try with proxies first, then direct
  const attempts = [...PROXIES.map(p => p + encodeURIComponent(url)), url];
  
  for(const attemptUrl of attempts) {
    try {
      const response = await fetch(attemptUrl);
      
      if(!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      // Get content length
      const contentLength = response.headers.get('content-length');
      const total = parseInt(contentLength, 10);
      
      // If no body stream support, just get blob
      if(!response.body) {
        return await response.blob();
      }
      
      // Read with progress
      const reader = response.body.getReader();
      const chunks = [];
      let received = 0;
      
      while(true) {
        const { done, value } = await reader.read();
        
        if(done) break;
        
        chunks.push(value);
        received += value.length;
        
        if(onProgress && total) {
          onProgress(Math.round((received / total) * 100));
        }
      }
      
      // Combine chunks into blob
      const blob = new Blob(chunks);
      return blob;
      
    } catch(error) {
      lastError = error;
      continue;
    }
  }
  
  throw lastError || new Error('All download attempts failed');
}

function showError(message) {
  previewArea.innerHTML = `<div class="error-msg">‚ùå ${message}</div>`;
}

function formatBytes(bytes) {
  if(!bytes || bytes === 0) return 'Unknown size';
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
}

function truncateUrl(url) {
  if(url.length > 80) {
    return url.substring(0, 80) + '...';
  }
  return url;
}

// Auto-focus on input
inputUrl.focus();
</script>
</body>
</html>